---
import Layout from '../../../layouts/Layout.astro';
import AppleCardDemoNav from '../../../components/AppleCardDemoNav.astro';
import { movies } from '../../../data/demo-movies';
---

<Layout title="3A: Greenfield Dialog" noindex={true}>
  <AppleCardDemoNav current="3a" />
  <div class="page-wrapper" id="page-wrapper">
    <div class="demo-page">
      <header class="page-header">
        <h1>3A: Greenfield Dialog</h1>
        <p>Native &lt;dialog&gt;, container FLIP (outer translate, inner scale), two-curve animation, shadow layer, interruptible, scroll-aware swipe.</p>
      </header>

      <div class="card-grid" id="card-grid">
        {movies.map((movie, i) => (
          <article
            class="movie-card"
            data-card-index={i}
            tabindex="0"
            role="button"
            aria-label={`View ${movie.title}`}
          >
            <img src={movie.poster} alt={movie.title} class="card-img" loading="lazy" />
          </article>
        ))}
      </div>
    </div>
  </div>

  <!-- Native dialog — gets focus trap, Escape, aria-modal for free -->
  <dialog class="card-dialog" id="card-dialog">
    <div class="dialog-shadow" id="dialog-shadow"></div>
    <div class="dialog-container" id="dialog-container">
      <div class="dialog-scaler" id="dialog-scaler">
        <div class="dialog-scroll" id="dialog-scroll">
          <div class="dialog-hero" id="dialog-hero">
            <img class="dialog-hero-img" id="dialog-hero-img" src="" alt="" />
          </div>
          <div class="dialog-body" id="dialog-body">
            <p class="body-description" id="body-description"></p>
            <div class="body-cast">
              <span class="cast-label">Starring</span>
              <p class="cast-names" id="cast-names"></p>
            </div>
            <div class="body-actions">
              <button class="action-btn action-primary">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><path d="M15.5 5l-7 7 7 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" transform="rotate(180 12 12)"/></svg>
                Get Tickets
              </button>
              <button class="action-btn action-secondary">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none"><rect x="3" y="4" width="18" height="18" rx="2" stroke="currentColor" stroke-width="2"/><path d="M16 2v4M8 2v4M3 10h18" stroke="currentColor" stroke-width="2" stroke-linecap="round"/></svg>
                Add to Calendar
              </button>
            </div>
            <div class="body-showtimes">
              <span class="showtimes-label">Upcoming Showtimes</span>
              <div class="showtimes-list" id="showtimes-list"></div>
            </div>
          </div>
        </div>
        <button class="close-btn" id="close-btn" aria-label="Close">
          <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
            <path d="M4 4l8 8M12 4l-8 8" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"/>
          </svg>
        </button>
        <div class="drag-handle" id="drag-handle"><div class="handle-pill"></div></div>
      </div>
    </div>
  </dialog>
</Layout>

<script define:vars={{ moviesJson: JSON.stringify(movies) }}>
(function () {
  'use strict';

  // ─── Config ────────────────────────────────────────────
  const DURATION = 500;
  const PAGE_SCALE = 0.94;
  // iOS-matching easing from Ionic — used for the positional (translate) curve
  const SPRING_EASE = 'cubic-bezier(0.32, 0.72, 0, 1)';
  // Gentler ease-out for the size (scale) curve — no overshoot
  const SCALE_EASE = 'cubic-bezier(0.25, 1, 0.5, 1)';
  const CLOSE_THRESHOLD = 0.25;
  const VELOCITY_THRESHOLD = 0.5; // px/ms

  const movieData = JSON.parse(moviesJson);
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  // ─── DOM refs ──────────────────────────────────────────
  const dialog = document.getElementById('card-dialog');
  const dialogContainer = document.getElementById('dialog-container');
  const dialogScaler = document.getElementById('dialog-scaler');
  const dialogScroll = document.getElementById('dialog-scroll');
  const dialogShadow = document.getElementById('dialog-shadow');
  const dialogHero = document.getElementById('dialog-hero');
  const dialogHeroImg = document.getElementById('dialog-hero-img');
  const dialogBody = document.getElementById('dialog-body');
  const closeBtn = document.getElementById('close-btn');
  const dragHandle = document.getElementById('drag-handle');
  const pageWrapper = document.getElementById('page-wrapper');
  const descEl = document.getElementById('body-description');
  const castEl = document.getElementById('cast-names');
  const showtimesList = document.getElementById('showtimes-list');

  // ─── State ─────────────────────────────────────────────
  let sourceCard = null;
  let savedSourceRect = null;
  let placeholder = null;
  let activeAnims = [];    // track all running WAAPI animations for interruption
  let isOpen = false;
  let isDragging = false;
  let dragStartY = 0;
  let dragCurrentY = 0;
  let dragStartTime = 0;

  // ─── Helpers ───────────────────────────────────────────
  function cancelAllAnims() {
    activeAnims.forEach(a => { try { a.cancel(); } catch(_) {} });
    activeAnims = [];
  }

  function runAnim(el, keyframes, options) {
    const anim = el.animate(keyframes, options);
    activeAnims.push(anim);
    return anim;
  }

  function commitAndCancel(anim, el, finalStyles) {
    return anim.finished.then(() => {
      Object.assign(el.style, finalStyles);
      anim.cancel();
      activeAnims = activeAnims.filter(a => a !== anim);
    });
  }

  function setPageOrigin() {
    const rect = pageWrapper.getBoundingClientRect();
    const originY = window.innerHeight / 2 - rect.top;
    pageWrapper.style.transformOrigin = `center ${originY}px`;
  }

  function isMobile() {
    return window.innerWidth < 640;
  }

  function populateDialog(movie) {
    dialogHeroImg.src = movie.poster;
    dialogHeroImg.alt = movie.title;
    descEl.textContent = movie.description;
    castEl.textContent = movie.actors;
    showtimesList.innerHTML = '';
    movie.showtimes.forEach(time => {
      const chip = document.createElement('span');
      chip.className = 'showtime-chip';
      chip.textContent = time;
      showtimesList.appendChild(chip);
    });
  }

  // ─── OPEN ──────────────────────────────────────────────
  function open(index, cardEl) {
    // Interrupt any in-flight animation
    cancelAllAnims();
    if (isOpen) return; // already open, don't re-enter

    sourceCard = cardEl;
    const movie = movieData[index];
    populateDialog(movie);

    // 1. Measure source before anything changes
    cardEl.style.transition = 'none';
    cardEl.style.transform = 'none';
    void cardEl.offsetHeight;
    const sourceRect = cardEl.getBoundingClientRect();
    savedSourceRect = sourceRect;

    // 2. Placeholder in grid
    placeholder = document.createElement('div');
    placeholder.className = 'card-placeholder';
    placeholder.style.aspectRatio = String(sourceRect.width / sourceRect.height);
    cardEl.parentNode.insertBefore(placeholder, cardEl);
    cardEl.style.visibility = 'hidden';
    cardEl.style.position = 'absolute';
    cardEl.style.pointerEvents = 'none';

    // 3. Show dialog (::backdrop appears, focus trap active)
    dialog.showModal();
    isOpen = true;

    // Reset scroll and body visibility
    dialogScroll.scrollTop = 0;
    dialogBody.style.opacity = '0';
    closeBtn.style.opacity = '0';
    closeBtn.style.transform = 'scale(0.8)';

    if (prefersReducedMotion) {
      dialogShadow.style.opacity = '1';
      dialogBody.style.opacity = '1';
      closeBtn.style.opacity = '1';
      closeBtn.style.transform = 'scale(1)';
      scalePageDown(0);
      return;
    }

    // 4. Measure dialog's final resting position
    void dialogScaler.offsetHeight;
    const expandedRect = dialogScaler.getBoundingClientRect();
    const heroRect = dialogHero.getBoundingClientRect();

    // 5. FLIP calculations — container approach
    // Container handles translate, scaler handles scale
    const scale = sourceRect.width / expandedRect.width;
    const dx = sourceRect.left - expandedRect.left;
    const dy = sourceRect.top - expandedRect.top;
    const bodyClip = expandedRect.height - heroRect.height;

    // 6. Two-curve animation
    // Curve A: translate (spring — can overshoot slightly)
    const translateAnim = runAnim(dialogContainer, [
      { transform: `translate(${dx}px, ${dy}px)` },
      { transform: 'translate(0px, 0px)' }
    ], { duration: DURATION, easing: SPRING_EASE, fill: 'forwards' });

    // Curve B: scale + clip-path (ease-out — no overshoot)
    dialogScaler.style.transformOrigin = 'top left';
    const scaleAnim = runAnim(dialogScaler, [
      {
        transform: `scale(${scale})`,
        clipPath: `inset(0px 0px ${bodyClip}px 0px round 16px)`,
        borderRadius: '16px',
      },
      {
        transform: 'scale(1)',
        clipPath: `inset(0px 0px 0px 0px round ${isMobile() ? '16px 16px 0px 0px' : '16px'})`,
        borderRadius: isMobile() ? '16px 16px 0 0' : '16px',
      }
    ], { duration: DURATION, easing: SCALE_EASE, fill: 'forwards' });

    // Shadow layer — opacity fade (separate element, not box-shadow on scaled card)
    const shadowAnim = runAnim(dialogShadow, [
      { opacity: 0, transform: `translate(${dx}px, ${dy}px) scale(${scale})` },
      { opacity: 1, transform: 'translate(0px, 0px) scale(1)' }
    ], { duration: DURATION, easing: SCALE_EASE, fill: 'forwards' });

    // Page scale-down
    scalePageDown(DURATION);

    // Close button entrance (delayed)
    const closeDelay = Math.round(DURATION * 0.55);
    setTimeout(() => {
      if (!isOpen) return;
      closeBtn.style.transition = `opacity 200ms ease-out, transform 200ms ease-out`;
      closeBtn.style.opacity = '1';
      closeBtn.style.transform = 'scale(1)';
    }, closeDelay);

    // Body staggered fade-in
    const bodyChildren = dialogBody.querySelectorAll('.body-description, .body-cast, .body-actions, .body-showtimes');
    const baseDelay = Math.round(DURATION * 0.3);
    const staggerGap = 50;
    bodyChildren.forEach((child, i) => {
      child.style.opacity = '0';
      child.style.transform = 'translateY(8px)';
      child.style.transition = 'none';
    });
    void dialogBody.offsetHeight;
    dialogBody.style.opacity = '1';
    bodyChildren.forEach((child, i) => {
      const delay = baseDelay + i * staggerGap;
      child.style.transition = `opacity 300ms ease-out ${delay}ms, transform 300ms ease-out ${delay}ms`;
      child.style.opacity = '1';
      child.style.transform = 'translateY(0)';
    });

    // 7. Commit final state
    Promise.all([
      commitAndCancel(translateAnim, dialogContainer, { transform: '' }),
      commitAndCancel(scaleAnim, dialogScaler, { transform: '', clipPath: '', borderRadius: '', transformOrigin: '' }),
      commitAndCancel(shadowAnim, dialogShadow, { opacity: '1', transform: '' }),
    ]).then(() => {
      pageWrapper.style.transition = '';
      closeBtn.style.transition = '';
      bodyChildren.forEach(c => { c.style.transition = ''; c.style.transform = ''; });
    }).catch(() => {});
  }

  // ─── CLOSE ─────────────────────────────────────────────
  function close() {
    if (!isOpen) return;
    cancelAllAnims();

    if (prefersReducedMotion) {
      cleanup();
      return;
    }

    // 1. Fade out close button + body (fast, before FLIP)
    closeBtn.style.transition = 'opacity 120ms ease-in, transform 120ms ease-in';
    closeBtn.style.opacity = '0';
    closeBtn.style.transform = 'scale(0.8)';

    const bodyChildren = dialogBody.querySelectorAll('.body-description, .body-cast, .body-actions, .body-showtimes');
    bodyChildren.forEach(c => {
      c.style.transition = 'opacity 150ms ease-in, transform 150ms ease-in';
      c.style.opacity = '0';
      c.style.transform = 'translateY(8px)';
    });

    // 2. Scroll to top, lock scroll
    dialogScroll.scrollTop = 0;

    // 3. Measure
    void dialogScaler.offsetHeight;
    const expandedRect = dialogScaler.getBoundingClientRect();
    const heroRect = dialogHero.getBoundingClientRect();
    const targetRect = savedSourceRect;

    const scale = targetRect.width / expandedRect.width;
    const dx = targetRect.left - expandedRect.left;
    const dy = targetRect.top - expandedRect.top;
    const bodyClip = expandedRect.height - heroRect.height;

    // 4. Two-curve close animation
    const translateAnim = runAnim(dialogContainer, [
      { transform: 'translate(0px, 0px)' },
      { transform: `translate(${dx}px, ${dy}px)` }
    ], { duration: DURATION, easing: SPRING_EASE, fill: 'forwards' });

    dialogScaler.style.transformOrigin = 'top left';
    const scaleAnim = runAnim(dialogScaler, [
      {
        transform: 'scale(1)',
        clipPath: `inset(0px 0px 0px 0px round ${isMobile() ? '16px 16px 0px 0px' : '16px'})`,
        borderRadius: isMobile() ? '16px 16px 0 0' : '16px',
      },
      {
        transform: `scale(${scale})`,
        clipPath: `inset(0px 0px ${bodyClip}px 0px round 16px)`,
        borderRadius: '16px',
      }
    ], { duration: DURATION, easing: SCALE_EASE, fill: 'forwards' });

    const shadowAnim = runAnim(dialogShadow, [
      { opacity: 1, transform: 'translate(0px, 0px) scale(1)' },
      { opacity: 0, transform: `translate(${dx}px, ${dy}px) scale(${scale})` }
    ], { duration: DURATION, easing: SCALE_EASE, fill: 'forwards' });

    // Page scale-up
    scalePageUp(DURATION);

    // 5. Cleanup on finish
    Promise.all([
      translateAnim.finished,
      scaleAnim.finished,
      shadowAnim.finished,
    ]).then(() => {
      cancelAllAnims();
      cleanup();
    }).catch(() => {
      cleanup();
    });
  }

  // ─── CLEANUP ───────────────────────────────────────────
  function cleanup() {
    cancelAllAnims();
    dialog.close();
    isOpen = false;

    // Restore source card into grid
    if (sourceCard && placeholder && placeholder.parentNode) {
      placeholder.parentNode.insertBefore(sourceCard, placeholder);
      placeholder.remove();
    }
    if (sourceCard) {
      sourceCard.style.visibility = '';
      sourceCard.style.position = '';
      sourceCard.style.pointerEvents = '';
      sourceCard.style.transition = '';
      sourceCard.style.transform = '';
    }

    // Reset dialog styles
    dialogContainer.style.transform = '';
    dialogScaler.style.transform = '';
    dialogScaler.style.clipPath = '';
    dialogScaler.style.borderRadius = '';
    dialogScaler.style.transformOrigin = '';
    dialogShadow.style.opacity = '';
    dialogShadow.style.transform = '';
    dialogBody.style.opacity = '';
    closeBtn.style.opacity = '';
    closeBtn.style.transform = '';
    closeBtn.style.transition = '';

    const bodyChildren = dialogBody.querySelectorAll('.body-description, .body-cast, .body-actions, .body-showtimes');
    bodyChildren.forEach(c => {
      c.style.opacity = '';
      c.style.transform = '';
      c.style.transition = '';
    });

    // Reset page
    pageWrapper.style.transition = '';
    pageWrapper.style.transform = '';
    pageWrapper.style.borderRadius = '';
    pageWrapper.style.overflow = '';
    pageWrapper.style.transformOrigin = '';
    pageWrapper.style.willChange = '';

    sourceCard = null;
    placeholder = null;
    savedSourceRect = null;
    isDragging = false;
  }

  // ─── PAGE SCALE ────────────────────────────────────────
  function scalePageDown(dur) {
    setPageOrigin();
    pageWrapper.style.willChange = 'transform';
    if (dur > 0) {
      pageWrapper.style.transition = `transform ${dur}ms ${SPRING_EASE}, border-radius ${dur}ms ${SPRING_EASE}`;
    }
    pageWrapper.style.transform = `scale(${PAGE_SCALE})`;
    pageWrapper.style.borderRadius = '12px';
    pageWrapper.style.overflow = 'hidden';
  }

  function scalePageUp(dur) {
    pageWrapper.style.willChange = 'transform';
    pageWrapper.style.transition = `transform ${dur}ms ${SPRING_EASE}, border-radius ${dur}ms ${SPRING_EASE}`;
    pageWrapper.style.transform = '';
    pageWrapper.style.borderRadius = '';
  }

  // ─── SWIPE-TO-DISMISS (scroll-aware) ──────────────────
  // Pointer events for mouse (hero/handle only), touch events for touch (scroll-aware)
  let isTracking = false; // for touch: tracking before committing to drag

  function applyDragVisuals(deltaY) {
    if (deltaY < 0) {
      // Overdrag up — damped resistance
      const damped = Math.sqrt(Math.abs(deltaY)) * 3;
      dragCurrentY = -damped;
      dialogContainer.style.transform = `translateY(${-damped}px)`;
    } else {
      dragCurrentY = deltaY;
      dialogContainer.style.transform = `translateY(${deltaY}px)`;
      // Fade backdrop proportionally
      const height = dialogScaler.offsetHeight;
      const pct = Math.min(deltaY / height, 1);
      dialog.style.setProperty('--drag-opacity', String(Math.max(0, 1 - pct * 1.5)));
      // Progressive border-radius on card
      dialogScaler.style.borderRadius = `${Math.min(pct * 80, 24)}px`;
      // Scale page back up proportionally
      const pageScale = PAGE_SCALE + (1 - PAGE_SCALE) * pct;
      pageWrapper.style.transition = 'none';
      pageWrapper.style.transform = `scale(${pageScale})`;
      pageWrapper.style.borderRadius = `${Math.max(0, 12 * (1 - pct))}px`;
    }
  }

  function finishDrag() {
    if (!isOpen) return;
    const height = dialogScaler.offsetHeight;
    const pct = dragCurrentY / height;
    const elapsed = Date.now() - dragStartTime;
    const velocity = elapsed > 0 ? dragCurrentY / elapsed : 0;

    if (pct > CLOSE_THRESHOLD || velocity > VELOCITY_THRESHOLD) {
      // Dismiss — slide out downward then cleanup
      const remaining = height - dragCurrentY;
      const dismissDur = Math.max(150, Math.min(300, remaining / Math.max(velocity, 0.5)));
      const dismissAnim = runAnim(dialogContainer, [
        { transform: `translateY(${dragCurrentY}px)` },
        { transform: `translateY(${height + 40}px)` }
      ], { duration: dismissDur, easing: 'cubic-bezier(0.4, 0, 1, 1)', fill: 'forwards' });

      dialog.style.setProperty('--drag-opacity', '0');
      scalePageUp(dismissDur);

      dismissAnim.finished.then(() => {
        cancelAllAnims();
        cleanup();
        dialog.style.removeProperty('--drag-opacity');
        dialogContainer.style.transform = '';
        dialogScaler.style.borderRadius = '';
      }).catch(() => {
        cleanup();
        dialog.style.removeProperty('--drag-opacity');
      });
    } else {
      // Snap back
      dialogContainer.style.transition = `transform ${DURATION}ms ${SPRING_EASE}`;
      dialogContainer.style.transform = '';
      dialogScaler.style.transition = `border-radius ${DURATION}ms ${SPRING_EASE}`;
      dialogScaler.style.borderRadius = '';
      dialog.style.setProperty('--drag-opacity', '1');
      pageWrapper.style.transition = `transform ${DURATION}ms ${SPRING_EASE}, border-radius ${DURATION}ms ${SPRING_EASE}`;
      pageWrapper.style.transform = `scale(${PAGE_SCALE})`;
      pageWrapper.style.borderRadius = '12px';

      const onDone = (e) => {
        if (e.target !== dialogContainer || e.propertyName !== 'transform') return;
        dialogContainer.removeEventListener('transitionend', onDone);
        dialogContainer.style.transition = '';
        dialogScaler.style.transition = '';
        pageWrapper.style.transition = '';
        dialog.style.removeProperty('--drag-opacity');
      };
      dialogContainer.addEventListener('transitionend', onDone);
    }
    dragCurrentY = 0;
  }

  // Touch: scroll-aware — only begin drag when scrolled to top and swiping down
  dialog.addEventListener('touchstart', (e) => {
    if (!isOpen || isDragging) return;
    dragStartY = e.touches[0].clientY;
    dragStartTime = Date.now();
    dragCurrentY = 0;
    isTracking = true;
    isDragging = false;
  }, { passive: true });

  dialog.addEventListener('touchmove', (e) => {
    if (!isTracking) return;
    const currentY = e.touches[0].clientY;
    const deltaY = currentY - dragStartY;
    if (!isDragging) {
      if (Math.abs(deltaY) < 8) return; // dead zone
      if (deltaY > 0 && dialogScroll.scrollTop <= 0) {
        isDragging = true;
        dialogScaler.classList.add('dragging');
        cancelAllAnims(); // interrupt any running animation
      } else {
        isTracking = false;
        return;
      }
    }
    e.preventDefault();
    applyDragVisuals(deltaY);
  }, { passive: false });

  dialog.addEventListener('touchend', () => {
    const wasDragging = isDragging;
    isTracking = false;
    isDragging = false;
    if (!wasDragging) return;
    dialogScaler.classList.remove('dragging');
    finishDrag();
  }, { passive: true });

  // Pointer: hero + handle drag (mouse)
  dialog.addEventListener('pointerdown', (e) => {
    if (!isOpen) return;
    const hitHero = e.target.closest('.dialog-hero');
    const hitHandle = e.target.closest('.drag-handle');
    if (!hitHero && !hitHandle) return;
    if (dialogScroll.scrollTop > 0) return;
    if (e.button !== 0 && e.pointerType === 'mouse') return;

    isDragging = true;
    dragStartY = e.clientY;
    dragCurrentY = 0;
    dragStartTime = Date.now();
    dialogScaler.classList.add('dragging');
    dialogContainer.setPointerCapture(e.pointerId);
    cancelAllAnims();
    e.preventDefault();
  });

  document.addEventListener('pointermove', (e) => {
    if (!isDragging || isTracking) return;
    applyDragVisuals(e.clientY - dragStartY);
  });

  document.addEventListener('pointerup', (e) => {
    if (!isDragging || isTracking) return;
    isDragging = false;
    dialogScaler.classList.remove('dragging');
    try { dialogContainer.releasePointerCapture(e.pointerId); } catch(_) {}
    finishDrag();
  });

  // ─── Event listeners ──────────────────────────────────
  document.querySelectorAll('.movie-card').forEach(cardEl => {
    cardEl.addEventListener('click', () => {
      if (isOpen) return;
      open(parseInt(cardEl.dataset.cardIndex, 10), cardEl);
    });
    cardEl.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        if (isOpen) return;
        open(parseInt(cardEl.dataset.cardIndex, 10), cardEl);
      }
    });
  });

  closeBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    close();
  });

  // Native dialog fires 'cancel' on Escape — use it instead of manual keydown
  dialog.addEventListener('cancel', (e) => {
    e.preventDefault(); // prevent instant close, animate instead
    close();
  });

  // Click on backdrop (::backdrop is not clickable, but we can detect clicks outside the container)
  dialog.addEventListener('click', (e) => {
    if (e.target === dialog) close();
  });

  // Resize: update saved source rect from placeholder
  let resizeTimeout;
  window.addEventListener('resize', () => {
    if (!isOpen || !placeholder) return;
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      if (!placeholder) return;
      savedSourceRect = placeholder.getBoundingClientRect();
    }, 150);
  });

})();
</script>

<style>
  /* =============================================
     PAGE LAYOUT
     ============================================= */
  .page-wrapper {
    background: var(--bg-body);
    min-height: 100vh;
  }

  .demo-page {
    max-width: 900px;
    margin: 0 auto;
    padding: 0 16px 60px;
  }

  .page-header {
    padding: 24px 0 32px;
  }

  .page-header h1 {
    font-family: 'Barlow Condensed', sans-serif;
    font-weight: 600;
    font-size: 28px;
    letter-spacing: -0.01em;
    color: var(--text-primary);
    margin: 0 0 6px;
  }

  .page-header p {
    font-size: 14px;
    color: var(--text-secondary);
    margin: 0;
  }

  /* =============================================
     CARD GRID
     ============================================= */
  .card-grid {
    display: grid;
    grid-template-columns: 1fr;
    gap: 20px;
  }

  @media (min-width: 640px) {
    .card-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  :global(.card-placeholder) {
    border-radius: 16px;
  }

  /* =============================================
     MOVIE CARD (GRID STATE)
     ============================================= */
  .movie-card {
    position: relative;
    border-radius: 16px;
    overflow: hidden;
    cursor: pointer;
    -webkit-tap-highlight-color: transparent;
    transition: transform 0.15s ease;
    outline: none;
    box-shadow:
      0 2px 8px rgba(0, 0, 0, 0.25),
      0 8px 24px rgba(0, 0, 0, 0.15);
  }

  @media (hover: hover) {
    .movie-card:hover {
      transform: scale(1.02);
    }
  }

  .movie-card:active {
    transform: scale(0.98);
    transition-duration: 0.1s;
  }

  .movie-card:focus-visible {
    box-shadow: 0 0 0 3px var(--accent);
  }

  .card-img {
    display: block;
    width: 100%;
    height: auto;
  }

  /* =============================================
     NATIVE DIALOG
     ============================================= */
  .card-dialog {
    /* Reset dialog defaults */
    border: none;
    padding: 0;
    margin: 0;
    max-width: none;
    max-height: none;
    width: 100vw;
    height: 100vh;
    background: transparent;
    overflow: visible;
    /* Sit on top of everything */
    position: fixed;
    inset: 0;
  }

  .card-dialog::backdrop {
    background: rgba(0, 0, 0, 0.85);
    opacity: var(--drag-opacity, 1);
    transition: opacity 0.15s ease;
  }

  /* =============================================
     DIALOG CONTAINER (handles translate)
     ============================================= */
  .dialog-container {
    position: fixed;
    inset: 0;
    display: flex;
    /* Mobile: bottom-aligned. Desktop: centered. */
    align-items: flex-end;
    justify-content: center;
    pointer-events: none;
  }

  @media (min-width: 640px) {
    .dialog-container {
      align-items: center;
    }
  }

  /* =============================================
     DIALOG SCALER (handles scale + clip-path)
     ============================================= */
  .dialog-scaler {
    position: relative;
    width: 100%;
    max-height: calc(100svh - env(safe-area-inset-top, 0px) - 20px);
    border-radius: 16px 16px 0 0;
    clip-path: inset(0 round 16px 16px 0 0);
    background: #000; /* Lesson #10: black bg for AA corner fringe */
    pointer-events: auto;
    overflow: hidden;
  }

  @media (min-width: 640px) {
    .dialog-scaler {
      width: 520px;
      max-height: calc(100vh - 80px);
      border-radius: 16px;
      clip-path: inset(0 round 16px);
    }
  }

  .dialog-scaler.dragging {
    transition: none !important;
  }

  /* =============================================
     DIALOG SHADOW (separate element — opacity animated)
     ============================================= */
  .dialog-shadow {
    position: fixed;
    pointer-events: none;
    /* Mirror the container's position */
    inset: 0;
    display: flex;
    align-items: flex-end;
    justify-content: center;
    opacity: 0;
    z-index: -1;
  }

  .dialog-shadow::after {
    content: '';
    width: 100%;
    max-height: calc(100svh - env(safe-area-inset-top, 0px) - 20px);
    /* Approximate the scaler's dimensions */
    aspect-ratio: 520 / 700;
    border-radius: 16px 16px 0 0;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5), 0 8px 32px rgba(0, 0, 0, 0.3);
  }

  @media (min-width: 640px) {
    .dialog-shadow {
      align-items: center;
    }
    .dialog-shadow::after {
      width: 520px;
      border-radius: 16px;
    }
  }

  /* =============================================
     SCROLLABLE CONTENT AREA
     ============================================= */
  .dialog-scroll {
    max-height: calc(100svh - env(safe-area-inset-top, 0px) - 20px);
    overflow-y: auto;
    overscroll-behavior-y: none;
    background: var(--bg-body);
  }

  @media (min-width: 640px) {
    .dialog-scroll {
      max-height: calc(100vh - 80px);
    }
  }

  /* =============================================
     HERO IMAGE
     ============================================= */
  .dialog-hero {
    position: relative;
    aspect-ratio: 4 / 3;
    overflow: hidden;
    background: #111;
  }

  .dialog-hero-img {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* =============================================
     CLOSE BUTTON
     ============================================= */
  .close-btn {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 20;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.45);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: none;
    border-radius: 50%;
    color: #fff;
    cursor: pointer;
    transition: background 0.15s, transform 0.1s;
  }

  @media (hover: hover) {
    .close-btn:hover { background: rgba(0, 0, 0, 0.7); }
  }

  .close-btn:active { transform: scale(0.9) !important; }

  /* =============================================
     DRAG HANDLE
     ============================================= */
  .drag-handle {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    z-index: 20;
    display: flex;
    justify-content: center;
    padding: 8px 0;
    cursor: grab;
    touch-action: none;
  }

  .handle-pill {
    width: 48px;
    height: 5px;
    border-radius: 3px;
    background: rgba(255, 255, 255, 0.7);
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.3);
  }

  @media (min-width: 640px) {
    .drag-handle { display: none; }
  }

  /* =============================================
     BODY CONTENT
     ============================================= */
  .dialog-body {
    padding: 24px 20px 40px;
    display: flex;
    flex-direction: column;
    gap: 24px;
  }

  .body-description {
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-primary);
    margin: 0;
  }

  .body-cast {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .cast-label,
  .showtimes-label {
    font-family: 'Barlow Semi Condensed', sans-serif;
    font-weight: 600;
    font-size: 11px;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--text-secondary);
  }

  .cast-names {
    font-size: 14px;
    line-height: 1.5;
    color: var(--text-primary);
    margin: 0;
  }

  .body-actions {
    display: flex;
    gap: 10px;
  }

  .action-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 12px 16px;
    border: none;
    border-radius: 12px;
    font-family: 'IBM Plex Sans', sans-serif;
    font-weight: 500;
    font-size: 14px;
    cursor: pointer;
    transition: transform 0.1s, opacity 0.15s;
  }

  .action-btn:active { transform: scale(0.97); }

  .action-primary {
    background: var(--accent);
    color: #fff;
  }

  @media (hover: hover) {
    .action-primary:hover { transform: scale(1.05); }
    .action-secondary:hover { background: var(--bg-movie-hover); }
  }

  .action-secondary {
    background: var(--bg-movie);
    color: var(--text-primary);
  }

  .body-showtimes {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  :global(.showtimes-list) {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  :global(.showtime-chip) {
    display: inline-block;
    padding: 8px 14px;
    background: var(--bg-movie);
    color: var(--text-primary);
    font-size: 13px;
    font-weight: 500;
    border-radius: 8px;
    white-space: nowrap;
  }

  /* =============================================
     REDUCED MOTION
     ============================================= */
  @media (prefers-reduced-motion: reduce) {
    .movie-card,
    .card-dialog::backdrop,
    .page-wrapper {
      transition: none !important;
    }
    .movie-card:hover,
    .movie-card:active {
      transform: none;
    }
  }
</style>
