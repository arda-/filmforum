---
import Layout from '@layouts/Layout.astro';
import Header from '@components/Header.astro';
import MovieModal from '@components/MovieModal.astro';
import CalendarFilterBar from '@components/CalendarFilterBar.astro';
import CalendarViewToolbar from '@components/CalendarViewToolbar.astro';
import CalendarBottomBar from '@components/CalendarBottomBar.astro';
import { DialogRoot, DialogHeader, DialogTitle, DialogDescription, DialogBody } from '@components/Dialog/index';
import { getAllSeriesIds, getSeriesConfig } from '@config/series';
import { loadMovieData } from '@utils/loadMovieData';

export function getStaticPaths() {
  return getAllSeriesIds().map(id => ({ params: { id } }));
}

const { id } = Astro.params;
const series = getSeriesConfig(id)!;

// Load movie data at build time
const { movieData, movieDataJson } = loadMovieData(series.dataFile);

// Count showtimes for SEO description
const showtimeCount = movieData.length;

// SEO metadata
const title = `${series.name} Calendar - ${series.venueName} Showtimes`;
const description = `Interactive calendar for ${series.name} at ${series.venueName}. Browse ${showtimeCount}+ showtimes, filter by day, and plan your visits. ${series.dateRange}.`;
const canonical = `/s/${id}/calendar`;
const ogImage = movieData[0]?.poster_url || null;
---

<Layout
  title={title}
  description={description}
  canonical={canonical}
  ogImage={ogImage}
  ogImageAlt={`${series.name} calendar view`}
  fullWidth
>
  <Header
    seriesName={series.name}
    seriesSubtitle={series.subtitle}
    seriesUrl={series.seriesUrl}
    venueName={series.venueName}
    dateRange={series.dateRange}
  />

  <CalendarFilterBar />
  <CalendarViewToolbar />

  <div class="calendar-scroll-container">
    <div class="calendar"></div>
  </div>

  <p class="legend">
    Click any movie for details. Times are PM unless marked "FF Jr."<br />
    <span class="legend-star">&#9733;</span> Unique showtime (no other showtimes for this movie with current filters).
  </p>

  <CalendarBottomBar />

  <MovieModal />

  <!-- Hidden Movies Modal -->
  <DialogRoot id="hidden-movies-modal" size="md">
    <DialogHeader>
      <DialogTitle>Hidden Weekday 9-5 Showtimes</DialogTitle>
      <DialogDescription>These showtimes are hidden because they fall during weekday work hours (9am-5pm).</DialogDescription>
    </DialogHeader>
    <DialogBody scroll>
      <div id="hidden-movies-list" class="hidden-movies-list"></div>
    </DialogBody>
  </DialogRoot>

  <!-- Weekday Movies Modal (for weekends-only filter) -->
  <DialogRoot id="weekday-movies-modal" size="md">
    <DialogHeader>
      <DialogTitle>Hidden Weekday Showtimes</DialogTitle>
      <DialogDescription>These showtimes are hidden because they fall on weekdays (Mon-Fri).</DialogDescription>
    </DialogHeader>
    <DialogBody scroll>
      <div id="weekday-movies-list" class="hidden-movies-list"></div>
    </DialogBody>
  </DialogRoot>

  <!-- Fit Width Warning Modal -->
  <DialogRoot id="fit-width-warning-modal" size="sm">
    <DialogHeader>
      <DialogTitle>Disable Fit Width?</DialogTitle>
      <DialogDescription>Showing Cast or Image requires more space and will disable "Fit width" mode.</DialogDescription>
    </DialogHeader>
    <DialogBody>
      <label style="display: flex; align-items: center; gap: 8px; font-size: 14px; cursor: pointer;">
        <input type="checkbox" id="fit-width-warning-dont-show" style="cursor: pointer;" />
        <span>Do not show this warning again</span>
      </label>
    </DialogBody>
    <div class="dialog-footer">
      <button id="fit-width-warning-cancel" class="dialog-btn dialog-btn-secondary">Cancel</button>
      <button id="fit-width-warning-confirm" class="dialog-btn dialog-btn-primary">Disable Fit Width</button>
    </div>
  </DialogRoot>

</Layout>

<script define:vars={{ movieDataJson, sessionId: id }}>
  window.__movieData = JSON.parse(movieDataJson);
  window.__sessionId = sessionId;
</script>

<script>
  import {
    PX_PER_MIN,
    MIN_TIMELINE_HEIGHT,
    TIMELINE_PADDING,
    HOURS_FILTER_MODE,
    SINGLE_SHOWTIMES_MODE,
    SAVED_FILTER_COUNT,
    type HoursFilterMode,
    type SingleShowtimesMode,
    type SavedFilter,
  } from '@/constants';
  import type { Movie } from '@utils/icsGenerator';
  import { createMovieElement, updateTextHeights } from '@components/MovieTile';
  import { parseTimeToMins, getDayTimeRange, assignOverlapColumns, formatDayLabel, generateDateRange, groupDatesIntoWeeks, getWeekTimeRange } from '@utils/calendarTime';
  import { updateHoursFilterStatus, filterDayMovies, getHiddenWorkHoursMovies, getWeekdayMovies, filterBySavedStatus, updateSavedFilterStatus } from '@utils/calendarFilters';
  import { openMovieModal, renderMovieList } from '@utils/calendarModal';
  import { updateUrlParams, restoreFromUrl, isTogglePressed, setToggleState, getToggleInput } from '@utils/calendarUrlState';
  import { getReactions } from '@utils/storageManager';
  import type { ReactionMap } from '@types/session';

  // --- State ---
  let moviesByDate: Record<string, Movie[]> = {};
  let allMovies: Movie[] = [];
  let allMovieDates: string[] = [];
  let movieByKey: Map<string, Movie> = new Map();
  const sessionId = window.__sessionId;
  let currentReactions: ReactionMap = getReactions(sessionId);

  // Cache computed date ranges to avoid redundant computation in renderAllDays
  let cachedDates: string[] | null = null;
  let cachedMondayStart: boolean | null = null;

  /** Read which saved filter checkboxes are currently checked. */
  function getActiveSavedFilters(): SavedFilter[] {
    const checked = document.querySelectorAll('input[name="saved-filter"]:checked');
    return Array.from(checked).map(el => (el as HTMLInputElement).value as SavedFilter);
  }

  /** Whether the user has any reactions at all. */
  function hasAnyReactions(reactions: ReactionMap): boolean {
    return Object.keys(reactions).length > 0;
  }

  /** Read the week-start toggle and return whether weeks should start on Monday. */
  function getWeekStartPreference(): boolean {
    const weekStartToggle = document.getElementById('week-start-toggle');
    const weekStartInput = weekStartToggle?.tagName === 'INPUT'
      ? weekStartToggle as HTMLInputElement
      : weekStartToggle?.querySelector('input') as HTMLInputElement;
    return weekStartInput?.checked ?? true;
  }

  interface FilterOptions {
    hoursFilterMode: HoursFilterMode;
    savedFilterSet: Set<SavedFilter>;
    reactions: ReactionMap;
    singleShowtimesMode: SingleShowtimesMode;
    filteredShowtimeCounts: Record<string, number>;
  }

  /**
   * Apply the complete filter pipeline to movies for a given date.
   * This includes hours filter, saved status filter, and single showtimes filter.
   */
  function applyFilterPipeline(
    date: string,
    rawMovies: Movie[],
    options: FilterOptions
  ): Movie[] {
    let filtered = filterDayMovies(rawMovies, date, options.hoursFilterMode);

    if (options.savedFilterSet.size < SAVED_FILTER_COUNT) {
      filtered = filterBySavedStatus(filtered, options.reactions, options.savedFilterSet);
    }

    // Filter to only show unique if that mode is selected
    if (options.singleShowtimesMode === SINGLE_SHOWTIMES_MODE.ONLY || options.singleShowtimesMode === 'only') {
      filtered = filtered.filter(m => options.filteredShowtimeCounts[m.Movie] === 1);
    }

    return filtered;
  }

  // --- Calendar rendering ---
  function createDayCell(date: string): HTMLElement {
    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    dayEl.dataset.date = date;
    dayEl.dataset.dayNumber = formatDayLabel(date);
    const labelEl = document.createElement('div');
    labelEl.className = 'day-number';
    labelEl.textContent = formatDayLabel(date);
    dayEl.appendChild(labelEl);
    return dayEl;
  }

  function renderCalendar() {
    const mondayStart = getWeekStartPreference();

    const dates = generateDateRange(allMovieDates, mondayStart);
    // Cache the computed dates to avoid redundant computation in renderAllDays
    cachedDates = dates;
    cachedMondayStart = mondayStart;

    const calendarEl = document.querySelector('.calendar');
    if (!calendarEl) return;

    calendarEl.innerHTML = '';
    dates.forEach(date => calendarEl.appendChild(createDayCell(date)));
    renderAllDays();
  }

  function renderAllDays() {
    // Re-read reactions from localStorage so modal changes are reflected
    currentReactions = getReactions(sessionId);
    updateSavedFilterCounts();

    const timelineToggle = document.getElementById('timeline-mode-toggle');
    const timelineInput = timelineToggle?.tagName === 'INPUT' ? timelineToggle : timelineToggle?.querySelector('input');
    const timelineMode = (timelineInput as HTMLInputElement)?.checked ?? false;

    const hoursFilterSelect = document.getElementById('hours-filter-select') as HTMLSelectElement;
    const hoursFilterMode = (hoursFilterSelect?.value || HOURS_FILTER_MODE.NONE) as HoursFilterMode;

    const singleShowtimesRadio = document.querySelector('input[name="single-showtimes-mode"]:checked') as HTMLInputElement;
    const singleShowtimesFilter = (singleShowtimesRadio?.value || SINGLE_SHOWTIMES_MODE.NONE) as SingleShowtimesMode;

    // Check if highlight unique is enabled (from gear menu)
    const highlightUniqueToggle = document.querySelector('#highlight-unique-toggle input') as HTMLInputElement;
    const singleShowtimesMode = highlightUniqueToggle?.checked ? 'highlight' : singleShowtimesFilter;

    const activeSavedFilters = getActiveSavedFilters();
    const savedFilterSet = new Set(activeSavedFilters);

    updateHoursFilterStatus(hoursFilterMode, allMovies);
    updateSavedFilterStatus(savedFilterSet, allMovies, currentReactions);

    // Showtime counts are computed before the saved filter so that "single showtime"
    // means one showtime across the entire festival, not one among visible results.
    // Build count of filtered showtimes per movie title
    const filteredShowtimeCounts: Record<string, number> = {};
    Object.entries(moviesByDate).forEach(([date, dayMovies]) => {
      filterDayMovies(dayMovies, date, hoursFilterMode).forEach(m => {
        filteredShowtimeCounts[m.Movie] = (filteredShowtimeCounts[m.Movie] || 0) + 1;
      });
    });

    // Pre-calculate week time ranges for timeline mode and cache filtered results
    const weekRangesByDate = new Map<string, { start: number; end: number; range: number }>();
    const filteredMoviesByDate = new Map<string, Movie[]>();

    if (timelineMode) {
      const mondayStart = getWeekStartPreference();

      // Defensive recomputation: renderAllDays() is called either from renderCalendar()
      // (which just cached dates) or from event handlers. The cache is only invalidated
      // if the week-start preference changes, which event handlers shouldn't do.
      // This defensive logic guards against edge cases while keeping the contract simple.
      const dates = cachedDates && cachedMondayStart === mondayStart
        ? cachedDates
        : generateDateRange(allMovieDates, mondayStart);

      // Update cache if new dates were generated (not reusing cached dates)
      if (dates !== cachedDates) {
        cachedDates = dates;
        cachedMondayStart = mondayStart;
      }

      const weeks = groupDatesIntoWeeks(dates);

      // First pass: compute and cache filtered movies for all dates
      weeks.forEach(weekDates => {
        weekDates.forEach(date => {
          const dayMovies = moviesByDate[date] || [];
          const filtered = applyFilterPipeline(
            date,
            dayMovies,
            {
              hoursFilterMode,
              savedFilterSet,
              reactions: currentReactions,
              singleShowtimesMode,
              filteredShowtimeCounts
            }
          );
          filteredMoviesByDate.set(date, filtered);
        });
      });

      // Second pass: compute week time ranges from cached filtered results
      weeks.forEach(weekDates => {
        const weekRange = getWeekTimeRange(weekDates, (date) => {
          return filteredMoviesByDate.get(date) || [];
        });

        // Store the week range for all dates in this week
        weekDates.forEach(date => weekRangesByDate.set(date, weekRange));
      });
    }

    // Render all days using cached filtered results (if available in timeline mode) or fresh calculations
    // Note: In non-timeline mode, filteredMoviesByDate is empty, so all dates hit the fallback path and recalculate
    Object.entries(moviesByDate).forEach(([date, dayMovies]) => {
      // Use cached results if available (from timeline pre-calculation), otherwise recalculate
      const filteredMovies = filteredMoviesByDate.get(date) ?? applyFilterPipeline(
        date,
        dayMovies,
        {
          hoursFilterMode,
          savedFilterSet,
          reactions: currentReactions,
          singleShowtimesMode,
          filteredShowtimeCounts
        }
      );

      const dayCell = document.querySelector(`[data-date="${date}"]`) as HTMLElement;
      if (!dayCell) return;

      const dayNumber = dayCell.dataset.dayNumber;
      dayCell.innerHTML = '';
      dayCell.classList.remove('timeline-view');
      dayCell.classList.add('has-movies');
      dayCell.style.height = '';

      const dayNumDiv = document.createElement('div');
      dayNumDiv.className = 'day-number';
      dayNumDiv.textContent = dayNumber || '';
      dayCell.appendChild(dayNumDiv);

      if (filteredMovies.length === 0) {
        dayCell.classList.remove('has-movies');
        return;
      }

      if (timelineMode) {
        // Use the pre-calculated week time range for this day
        const weekRange = weekRangesByDate.get(date);
        let dayHeight = MIN_TIMELINE_HEIGHT + TIMELINE_PADDING;
        let dayStartTime = 0;

        if (weekRange && weekRange.range > 0) {
          dayHeight = Math.max(weekRange.range * PX_PER_MIN, MIN_TIMELINE_HEIGHT) + TIMELINE_PADDING;
          dayStartTime = weekRange.start;
        } else {
          // Defensive fallback: calculate day's own range if weekRange is missing
          // (should not occur in practice - all dates from generateDateRange should have weekRange)
          // Note: We know filteredMovies.length > 0 here due to early return above when filteredMovies is empty
          const dayRange = getDayTimeRange(filteredMovies);
          dayHeight = Math.max(dayRange.range * PX_PER_MIN, MIN_TIMELINE_HEIGHT) + TIMELINE_PADDING;
          dayStartTime = dayRange.start;
        }

        dayCell.style.height = `${dayHeight}px`;
        dayCell.classList.add('timeline-view');
        assignOverlapColumns(filteredMovies).forEach(movie => {
          const start = parseTimeToMins(movie.Time);
          const runtime = parseInt(movie.runtime || '90');
          const topPx = (start - dayStartTime) * PX_PER_MIN;
          const heightPx = Math.max(runtime * PX_PER_MIN, 24);
          dayCell.appendChild(createMovieElement(movie, {
            isTimeline: true, topPx, heightPx,
            filteredCounts: filteredShowtimeCounts,
            singleShowtimeMode: singleShowtimesMode
          }));
        });
      } else {
        filteredMovies.forEach(movie => {
          dayCell.appendChild(createMovieElement(movie, {
            isTimeline: false,
            filteredCounts: filteredShowtimeCounts,
            singleShowtimeMode: singleShowtimesMode
          }));
        });
      }
    });
  }

  // --- Control event handlers ---
  document.getElementById('week-start-toggle')?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    document.body.classList.toggle('monday-start', checked);
    document.body.classList.toggle('sunday-start', !checked);
    updateUrlParams();
    renderCalendar();
    setTimeout(updateTextHeights, 10);
  });

  document.getElementById('timeline-mode-toggle')?.addEventListener('change', () => {
    renderAllDays();
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Fit width switch
  const fitWidthSwitch = document.querySelector('#fit-width-switch input') as HTMLInputElement;
  const showYearDirectorCheckbox = document.getElementById('show-year-director-checkbox') as HTMLInputElement;
  const showRuntimeCheckbox = document.getElementById('show-runtime-checkbox') as HTMLInputElement;
  const showActorsCheckbox = document.getElementById('show-actors-checkbox') as HTMLInputElement;
  const showImageCheckbox = document.getElementById('show-image-checkbox') as HTMLInputElement;

  // Helper to determine if minimum-width mode should be enabled
  // Content mode (fit width OFF) always enforces 640px minimum width
  function shouldEnableMinimumWidth(): boolean {
    const fitWidth = fitWidthSwitch?.checked ?? true;
    return !fitWidth;  // If NOT fit width (Content mode), always enforce minimum width
  }

  // Fit width switch
  fitWidthSwitch?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;

    // When fit width is enabled, disable other checkboxes
    if (checked) {
      showYearDirectorCheckbox.checked = false;
      showRuntimeCheckbox.checked = false;
      showActorsCheckbox.checked = false;
      showImageCheckbox.checked = false;
      document.body.classList.remove('show-year-director', 'show-runtime', 'show-actors', 'show-image', 'scrim-enabled', 'blur-enabled');
    }

    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
  });

  // Year/Director checkbox
  showYearDirectorCheckbox?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    document.body.classList.toggle('show-year-director', checked);
    if (checked) {
      fitWidthSwitch.checked = false;
      fitWidthSwitch.dispatchEvent(new Event('change', { bubbles: true }));
    }
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Runtime checkbox
  showRuntimeCheckbox?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    document.body.classList.toggle('show-runtime', checked);
    if (checked) {
      fitWidthSwitch.checked = false;
      fitWidthSwitch.dispatchEvent(new Event('change', { bubbles: true }));
    }
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Check localStorage for "don't show fit width warning" preference
  const FIT_WIDTH_WARNING_KEY = 'fit-width-warning-dismissed';
  function shouldShowFitWidthWarning(): boolean {
    return localStorage.getItem(FIT_WIDTH_WARNING_KEY) !== 'true';
  }

  let pendingCheckbox: HTMLInputElement | null = null;

  // Actors checkbox
  showActorsCheckbox?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;

    // If trying to enable while fit width is on, show warning
    if (checked && fitWidthSwitch?.checked && shouldShowFitWidthWarning()) {
      e.preventDefault();
      showActorsCheckbox.checked = false; // Revert the check
      pendingCheckbox = showActorsCheckbox;
      (window as any).openDialog('fit-width-warning-modal');
      return;
    }

    document.body.classList.toggle('show-actors', checked);
    if (checked) {
      fitWidthSwitch.checked = false;
      fitWidthSwitch.dispatchEvent(new Event('change', { bubbles: true }));
    }
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Image checkbox
  showImageCheckbox?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;

    // If trying to enable while fit width is on, show warning
    if (checked && fitWidthSwitch?.checked && shouldShowFitWidthWarning()) {
      e.preventDefault();
      showImageCheckbox.checked = false; // Revert the check
      pendingCheckbox = showImageCheckbox;
      (window as any).openDialog('fit-width-warning-modal');
      return;
    }

    document.body.classList.toggle('show-image', checked);
    document.body.classList.toggle('scrim-enabled', checked);
    document.body.classList.toggle('blur-enabled', checked);
    if (checked) {
      fitWidthSwitch.checked = false;
      fitWidthSwitch.dispatchEvent(new Event('change', { bubbles: true }));
    }
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Fit width warning modal handlers
  document.getElementById('fit-width-warning-confirm')?.addEventListener('click', () => {
    if (pendingCheckbox) {
      // Save "don't show again" preference if checked
      const dontShowCheckbox = document.getElementById('fit-width-warning-dont-show') as HTMLInputElement;
      if (dontShowCheckbox?.checked) {
        localStorage.setItem(FIT_WIDTH_WARNING_KEY, 'true');
      }

      // Disable fit width and enable the pending checkbox
      fitWidthSwitch.checked = false;
      fitWidthSwitch.dispatchEvent(new Event('change', { bubbles: true }));
      pendingCheckbox.checked = true;

      // Trigger the change logic
      if (pendingCheckbox === showActorsCheckbox) {
        document.body.classList.add('show-actors');
      } else if (pendingCheckbox === showImageCheckbox) {
        document.body.classList.add('show-image', 'scrim-enabled', 'blur-enabled');
      }

      document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
      updateUrlParams();
      setTimeout(updateTextHeights, 10);

      pendingCheckbox = null;
      (window as any).closeDialog('fit-width-warning-modal');
    }
  });

  document.getElementById('fit-width-warning-cancel')?.addEventListener('click', () => {
    pendingCheckbox = null;
    (window as any).closeDialog('fit-width-warning-modal');
  });

  // Hours filter dropdown
  document.getElementById('hours-filter-select')?.addEventListener('change', () => {
    renderAllDays();
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  document.querySelectorAll('input[name="single-showtimes-mode"]').forEach(radio => {
    radio.addEventListener('change', () => { renderAllDays(); updateUrlParams(); setTimeout(updateTextHeights, 10); });
  });

  document.querySelectorAll('input[name="saved-filter"]').forEach(checkbox => {
    checkbox.addEventListener('change', () => { renderAllDays(); updateUrlParams(); setTimeout(updateTextHeights, 10); });
  });

  // Highlight unique toggle
  document.querySelector('#highlight-unique-toggle input')?.addEventListener('change', () => {
    renderAllDays();
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // --- Load data and render ---
  const movies: Movie[] = window.__movieData;
  allMovies = movies;
  movies.forEach(movie => {
    const date = movie.Datetime.split('T')[0];
    if (!moviesByDate[date]) moviesByDate[date] = [];
    moviesByDate[date].push(movie);
    movieByKey.set(`${movie.Datetime}_${movie.Movie}`, movie);
  });

  allMovieDates = Object.keys(moviesByDate);

  // If user has no reactions, check all saved filter boxes (show everything)
  if (!hasAnyReactions(currentReactions)) {
    document.querySelectorAll<HTMLInputElement>('input[name="saved-filter"]').forEach(cb => {
      cb.checked = true;
    });
  }

  /** Update saved filter button labels with counts */
  function updateSavedFilterCounts() {
    // Get unique movies
    const uniqueMovies = new Set(allMovies.map(m => m.Movie));
    const counts = { yes: 0, maybe: 0, no: 0, unmarked: 0 };

    uniqueMovies.forEach(movieTitle => {
      const reaction = currentReactions[movieTitle] || 'none';
      if (reaction === 'yes') counts.yes++;
      else if (reaction === 'maybe') counts.maybe++;
      else if (reaction === 'no') counts.no++;
      else counts.unmarked++;
    });

    // Update button labels while preserving the hidden checkbox input
    const updateButton = (btn: Element | null, label: string) => {
      if (!btn) return;
      const checkbox = btn.querySelector('input[type="checkbox"]');
      if (checkbox) {
        // Remove all child nodes except the checkbox
        Array.from(btn.childNodes).forEach(node => {
          if (node !== checkbox) node.remove();
        });
        // Add the new text after the checkbox
        btn.appendChild(document.createTextNode(label));
      }
    };

    const yesBtn = document.querySelector('[data-filter="yes"]');
    const maybeBtn = document.querySelector('[data-filter="maybe"]');
    const noBtn = document.querySelector('[data-filter="no"]');
    const unmarkedBtn = document.querySelector('[data-filter="unmarked"]');

    updateButton(yesBtn, `Yes (${counts.yes})`);
    updateButton(maybeBtn, `Maybe (${counts.maybe})`);
    updateButton(noBtn, `No (${counts.no})`);
    updateButton(unmarkedBtn, `Unmarked (${counts.unmarked})`);
  }

  updateSavedFilterCounts();

  // Restore URL state silently before first render (no events, no re-renders)
  restoreFromUrl();

  // Signal toolbar to sync its button states from the restored checkboxes
  document.dispatchEvent(new Event('url-state-restored'));

  // Initialize minimum-width class based on fit-width switch and tile display options
  document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());

  // Single render with all state already applied
  renderCalendar();
  setTimeout(updateTextHeights, 10);

  // --- Width mode: Fit vs Content ---
  // Fit = fit to window width (no minimum)
  // Content = enforce 640px minimum width ALWAYS (enables horizontal scroll when needed)

  // --- DOMContentLoaded: event delegation ---
  document.addEventListener('DOMContentLoaded', () => {
    // Hidden showtimes modal handlers
    document.getElementById('hours-filter-status')?.addEventListener('click', () => {
      const hoursFilterRadio = document.querySelector('input[name="hours-filter-mode"]:checked') as HTMLInputElement;
      const mode = hoursFilterRadio?.value || 'none';
      if (mode === 'weekends') {
        const listEl = document.getElementById('weekday-movies-list');
        if (listEl) listEl.innerHTML = renderMovieList(getWeekdayMovies(allMovies));
        (window as any).openDialog('weekday-movies-modal');
      } else if (mode === 'afterhours') {
        const listEl = document.getElementById('hidden-movies-list');
        if (listEl) listEl.innerHTML = renderMovieList(getHiddenWorkHoursMovies(allMovies));
        (window as any).openDialog('hidden-movies-modal');
      }
    });

    // Pointer device detection
    if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {
      document.querySelectorAll('.desktop-only').forEach(el => el.classList.add('has-pointer'));
    }

    // Movie tile click â†’ modal
    function getMovieFromEl(el: Element): Movie | undefined {
      return movieByKey.get((el as HTMLElement).dataset.movieKey || '');
    }

    document.querySelector('.calendar')?.addEventListener('click', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-key]');
      if (movieEl) {
        const movie = getMovieFromEl(movieEl);
        if (movie) openMovieModal(movie);
      }
    });

    document.querySelector('.calendar')?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        const movieEl = (e.target as HTMLElement).closest('[data-movie-key]');
        if (movieEl) {
          e.preventDefault();
          const movie = getMovieFromEl(movieEl);
          if (movie) openMovieModal(movie);
        }
      }
    });

    // Highlight alternate showtimes on hover
    let currentHighlightedMovie: string | null = null;

    document.querySelector('.calendar')?.addEventListener('mouseover', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-title]');
      if (!movieEl) return;

      const highlightToggleEl = document.getElementById('highlight-alternate-toggle');
      const highlightEnabled = highlightToggleEl?.tagName === 'INPUT'
        ? (highlightToggleEl as HTMLInputElement).checked
        : (highlightToggleEl?.querySelector('input') as HTMLInputElement)?.checked;
      if (!highlightEnabled) return;

      const movieTitle = (movieEl as HTMLElement).dataset.movieTitle!;

      let visibleCount = 0;
      document.querySelectorAll('[data-movie-title]').forEach(el => {
        if ((el as HTMLElement).dataset.movieTitle === movieTitle) visibleCount++;
      });
      if (visibleCount <= 1) return;

      if (currentHighlightedMovie === movieTitle) return;
      currentHighlightedMovie = movieTitle;

      document.querySelectorAll('.alternate-highlight').forEach(el => el.classList.remove('alternate-highlight'));
      document.querySelectorAll('[data-movie-title]').forEach(el => {
        if ((el as HTMLElement).dataset.movieTitle === movieTitle) el.classList.add('alternate-highlight');
      });
    });

    document.querySelector('.calendar')?.addEventListener('mouseout', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-title]');
      const relatedTarget = (e as MouseEvent).relatedTarget as HTMLElement | null;
      const relatedMovieEl = relatedTarget?.closest('[data-movie-title]');

      if (movieEl && (!relatedMovieEl || relatedMovieEl !== movieEl)) {
        currentHighlightedMovie = null;
        document.querySelectorAll('.alternate-highlight').forEach(el => el.classList.remove('alternate-highlight'));
      }
    });
  });
</script>

<style>
  /* Calendar scroll container - only scrolls horizontally in minimum-width mode */
  .calendar-scroll-container {
    width: 100%;
  }

  :global(body.minimum-width) .calendar-scroll-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Day number styles (for dynamically recreated elements) */
  :global(.day-number) {
    font-size: 14px;
    line-height: 1;
    font-weight: 300;
    color: var(--text-tertiary);
    margin-bottom: 8px;
    padding-left: 4px;
    font-family: 'Barlow Condensed', sans-serif;
    text-transform: uppercase;
    letter-spacing: -0.015em;
  }

  @media (min-width: 480px) {
    :global(.day-number) {
      font-size: 13px;
      font-family: 'Barlow Semi Condensed', sans-serif;
      letter-spacing: -0.01em;
    }
  }

  @media (min-width: 640px) {
    :global(.day-number) {
      font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      text-transform: none;
      letter-spacing: normal;
      font-weight: 400;
    }
  }

  :global(.day.has-movies .day-number) {
    color: var(--text-secondary);
  }

  :global(.day.timeline-view .day-number) {
    position: absolute;
    top: 4px;
    left: 4px;
    z-index: 20;
    margin-bottom: 0;
  }

  @media (min-width: 768px) {
    :global(body.show-image .day-number) {
      font-weight: 500;
    }

    :global(.day-number) {
      padding-left: 6px;
    }
  }

  @media (min-width: 1024px) {
    :global(.day-number) {
      padding-left: 10px;
    }
  }

  /* Hidden movies list content styles */
  :global(.hidden-movies-list) {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  :global(.hidden-movie-item) {
    padding: 4px 0;
    border-bottom: 1px solid var(--bg-movie);
  }

  :global(.hidden-movie-item:last-child) {
    border-bottom: none;
  }

  :global(.hidden-movie-title) {
    font-weight: 500;
    color: var(--text-primary);
    display: inline;
  }

  :global(.hidden-movie-meta) {
    font-size: 12px;
    color: var(--text-tertiary);
    display: inline;
    margin-left: 6px;
  }

  :global(.hidden-movie-showtimes) {
    display: inline;
    margin-left: 6px;
    font-size: 12px;
    color: var(--text-tertiary);
  }

  :global(.hidden-showtime) {
    color: var(--text-secondary);
  }

  :global(.hidden-showtime:not(:last-child)::after) {
    content: ', ';
  }

  /* Dialog footer and button styles */
  .dialog-footer {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    padding-top: 16px;
  }

  .dialog-btn {
    padding: 8px 16px;
    font-size: 14px;
    font-family: inherit;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: background-color 0.15s ease;
  }

  .dialog-btn-primary {
    background: var(--accent);
    color: #fff;
  }

  .dialog-btn-primary:hover {
    background: var(--accent-bg);
  }

  .dialog-btn-secondary {
    background: var(--bg-movie);
    color: var(--text-primary);
    border: 1px solid var(--bg-movie-hover);
  }

  .dialog-btn-secondary:hover {
    background: var(--bg-movie-hover);
  }

</style>
