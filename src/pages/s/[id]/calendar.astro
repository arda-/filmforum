---
import Layout from '@layouts/Layout.astro';
import Header from '@components/Header.astro';
import MovieModal from '@components/MovieModal.astro';
import CalendarFilterBar from '@components/CalendarFilterBar.astro';
import CalendarViewToolbar from '@components/CalendarViewToolbar.astro';
import { DialogRoot, DialogHeader, DialogTitle, DialogDescription, DialogBody } from '@components/Dialog/index';
import { getAllSeriesIds, getSeriesConfig } from '@config/series';
import { loadMovieData } from '@utils/loadMovieData';

export function getStaticPaths() {
  return getAllSeriesIds().map(id => ({ params: { id } }));
}

const { id } = Astro.params;
const series = getSeriesConfig(id)!;

// Load movie data at build time
const { movieData, movieDataJson } = loadMovieData(series.dataFile);

// Count showtimes for SEO description
const showtimeCount = movieData.length;

// SEO metadata
const title = `${series.name} Calendar - ${series.venueName} Showtimes`;
const description = `Interactive calendar for ${series.name} at ${series.venueName}. Browse ${showtimeCount}+ showtimes, filter by day, and plan your visits. ${series.dateRange}.`;
const canonical = `/s/${id}/calendar`;
const ogImage = movieData[0]?.poster_url || null;
---

<Layout
  title={title}
  description={description}
  canonical={canonical}
  ogImage={ogImage}
  ogImageAlt={`${series.name} calendar view`}
  fullWidth
>
  <Header
    seriesName={series.name}
    seriesSubtitle={series.subtitle}
    seriesUrl={series.seriesUrl}
    venueName={series.venueName}
    dateRange={series.dateRange}
  />

  <CalendarFilterBar />
  <CalendarViewToolbar />

  <div class="calendar-scroll-container">
    <div class="calendar"></div>
  </div>

  <p class="legend">
    Click any movie for details. Times are PM unless marked "FF Jr."<br />
    <span class="legend-star">&#9733;</span> Unique showtime (no other showtimes for this movie with current filters).
  </p>


  <MovieModal />

  <!-- Hidden Movies Modal -->
  <DialogRoot id="hidden-movies-modal" size="md">
    <DialogHeader>
      <DialogTitle>Hidden Weekday 9-5 Showtimes</DialogTitle>
      <DialogDescription>These showtimes are hidden because they fall during weekday work hours (9am-5pm).</DialogDescription>
    </DialogHeader>
    <DialogBody scroll>
      <div id="hidden-movies-list" class="hidden-movies-list"></div>
    </DialogBody>
  </DialogRoot>

  <!-- Weekday Movies Modal (for weekends-only filter) -->
  <DialogRoot id="weekday-movies-modal" size="md">
    <DialogHeader>
      <DialogTitle>Hidden Weekday Showtimes</DialogTitle>
      <DialogDescription>These showtimes are hidden because they fall on weekdays (Mon-Fri).</DialogDescription>
    </DialogHeader>
    <DialogBody scroll>
      <div id="weekday-movies-list" class="hidden-movies-list"></div>
    </DialogBody>
  </DialogRoot>

</Layout>

<script define:vars={{ movieDataJson, sessionId: id }}>
  window.__movieData = JSON.parse(movieDataJson);
  window.__sessionId = sessionId;
</script>

<script>
  import {
    PX_PER_MIN,
    MIN_TIMELINE_HEIGHT,
    TIMELINE_PADDING,
    TIME_CATEGORY_COUNT,
    SAVED_FILTER_COUNT,
    type TimeCategory,
    type SavedFilter,
  } from '@utils/calendarConstants';
  import type { Movie } from '@utils/icsGenerator';
  import { createMovieElement, updateTextHeights } from '@components/MovieTile';
  import { parseTimeToMins } from '@utils/movieUtils';
  import { getDayTimeRange, assignOverlapColumns, formatDayLabel, generateDateRange, groupDatesIntoWeeks, getWeekTimeRange } from '@utils/calendarTime';
  import { filterByTimeCategories, classifyTimeCategory, filterBySavedStatus, updateSavedFilterStatus } from '@utils/calendarFilters';
  import { openMovieModal } from '@utils/calendarModal';
  import { updateUrlParams, restoreFromUrl, isTogglePressed, setToggleState, getToggleInput } from '@utils/calendarUrlState';
  import { getReactions } from '@utils/storageManager';
  import type { ReactionMap } from '@types/session';

  // --- State ---
  let moviesByDate: Record<string, Movie[]> = {};
  let allMovies: Movie[] = [];
  let allMovieDates: string[] = [];
  let movieByKey: Map<string, Movie> = new Map();
  const sessionId = window.__sessionId;
  let currentReactions: ReactionMap = getReactions(sessionId);

  // Cache computed date ranges to avoid redundant computation in renderAllDays
  let cachedDates: string[] | null = null;
  let cachedMondayStart: boolean | null = null;

  /** Read which saved filter checkboxes are currently checked. */
  function getActiveSavedFilters(): SavedFilter[] {
    const checked = document.querySelectorAll('input[name="saved-filter"]:checked');
    return Array.from(checked).map(el => (el as HTMLInputElement).value as SavedFilter);
  }

  /** Whether the user has any reactions at all. */
  function hasAnyReactions(reactions: ReactionMap): boolean {
    return Object.keys(reactions).length > 0;
  }

  /** Read the week-start toggle and return whether weeks should start on Monday. */
  function getWeekStartPreference(): boolean {
    const weekStartToggle = document.getElementById('week-start-toggle');
    const weekStartInput = weekStartToggle?.tagName === 'INPUT'
      ? weekStartToggle as HTMLInputElement
      : weekStartToggle?.querySelector('input') as HTMLInputElement;
    return weekStartInput?.checked ?? true;
  }

  interface FilterOptions {
    timeCategories: Set<TimeCategory>;
    savedFilterSet: Set<SavedFilter>;
    reactions: ReactionMap;
    filteredShowtimeCounts: Record<string, number>;
  }

  /**
   * Apply the complete filter pipeline to movies for a given date.
   * This includes time category filter and saved status filter.
   */
  function applyFilterPipeline(
    date: string,
    rawMovies: Movie[],
    options: FilterOptions
  ): Movie[] {
    let filtered = filterByTimeCategories(rawMovies, date, options.timeCategories);

    if (options.savedFilterSet.size < SAVED_FILTER_COUNT) {
      filtered = filterBySavedStatus(filtered, options.reactions, options.savedFilterSet);
    }

    return filtered;
  }

  // --- Calendar rendering ---
  function createDayCell(date: string): HTMLElement {
    const dayEl = document.createElement('div');
    dayEl.className = 'day';
    dayEl.dataset.date = date;
    dayEl.dataset.dayNumber = formatDayLabel(date);
    const labelEl = document.createElement('div');
    labelEl.className = 'day-number';
    labelEl.textContent = formatDayLabel(date);
    dayEl.appendChild(labelEl);
    return dayEl;
  }

  function renderCalendar() {
    const mondayStart = getWeekStartPreference();

    const dates = generateDateRange(allMovieDates, mondayStart);
    // Cache the computed dates to avoid redundant computation in renderAllDays
    cachedDates = dates;
    cachedMondayStart = mondayStart;

    const calendarEl = document.querySelector('.calendar');
    if (!calendarEl) return;

    calendarEl.innerHTML = '';
    dates.forEach(date => calendarEl.appendChild(createDayCell(date)));
    renderAllDays();
  }

  function renderAllDays() {
    // Re-read reactions from localStorage so modal changes are reflected
    currentReactions = getReactions(sessionId);
    updateSavedFilterCounts();

    const timelineToggle = document.getElementById('timeline-mode-toggle');
    const timelineInput = timelineToggle?.tagName === 'INPUT' ? timelineToggle : timelineToggle?.querySelector('input');
    const timelineMode = (timelineInput as HTMLInputElement)?.checked ?? false;

    // Read active time categories
    const timeChecked = document.querySelectorAll<HTMLInputElement>('input[name="time-filter"]:checked');
    const timeCategories = new Set(Array.from(timeChecked).map(cb => cb.value as TimeCategory));

    // Highlight unique showings (★) from gear menu toggle
    const highlightUniqueToggle = document.querySelector('#highlight-unique-toggle input') as HTMLInputElement;
    const singleShowtimesMode = (highlightUniqueToggle?.checked ?? false) ? 'highlight' : 'none';

    const activeSavedFilters = getActiveSavedFilters();
    const savedFilterSet = new Set(activeSavedFilters);

    updateSavedFilterStatus(savedFilterSet, allMovies, currentReactions);

    // Showtime counts are computed before the saved filter so that "single showtime"
    // means one showtime across the entire festival, not one among visible results.
    const filteredShowtimeCounts: Record<string, number> = {};
    Object.entries(moviesByDate).forEach(([date, dayMovies]) => {
      filterByTimeCategories(dayMovies, date, timeCategories).forEach(m => {
        filteredShowtimeCounts[m.Movie] = (filteredShowtimeCounts[m.Movie] || 0) + 1;
      });
    });

    // Pre-calculate week time ranges for timeline mode and cache filtered results
    const weekRangesByDate = new Map<string, { start: number; end: number; range: number }>();
    const filteredMoviesByDate = new Map<string, Movie[]>();

    if (timelineMode) {
      const mondayStart = getWeekStartPreference();

      // Defensive recomputation: renderAllDays() is called either from renderCalendar()
      // (which just cached dates) or from event handlers. The cache is only invalidated
      // if the week-start preference changes, which event handlers shouldn't do.
      // This defensive logic guards against edge cases while keeping the contract simple.
      const dates = cachedDates && cachedMondayStart === mondayStart
        ? cachedDates
        : generateDateRange(allMovieDates, mondayStart);

      // Update cache if new dates were generated (not reusing cached dates)
      if (dates !== cachedDates) {
        cachedDates = dates;
        cachedMondayStart = mondayStart;
      }

      const weeks = groupDatesIntoWeeks(dates);

      // First pass: compute and cache filtered movies for all dates
      weeks.forEach(weekDates => {
        weekDates.forEach(date => {
          const dayMovies = moviesByDate[date] || [];
          const filtered = applyFilterPipeline(
            date,
            dayMovies,
            {
              timeCategories,
              savedFilterSet,
              reactions: currentReactions,
              filteredShowtimeCounts
            }
          );
          filteredMoviesByDate.set(date, filtered);
        });
      });

      // Second pass: compute week time ranges from cached filtered results
      weeks.forEach(weekDates => {
        const weekRange = getWeekTimeRange(weekDates, (date) => {
          return filteredMoviesByDate.get(date) || [];
        });

        // Store the week range for all dates in this week
        weekDates.forEach(date => weekRangesByDate.set(date, weekRange));
      });
    }

    // Render all days using cached filtered results (if available in timeline mode) or fresh calculations
    // Note: In non-timeline mode, filteredMoviesByDate is empty, so all dates hit the fallback path and recalculate
    Object.entries(moviesByDate).forEach(([date, dayMovies]) => {
      // Use cached results if available (from timeline pre-calculation), otherwise recalculate
      const filteredMovies = filteredMoviesByDate.get(date) ?? applyFilterPipeline(
        date,
        dayMovies,
        {
          timeCategories,
          savedFilterSet,
          reactions: currentReactions,
          filteredShowtimeCounts
        }
      );

      const dayCell = document.querySelector(`[data-date="${date}"]`) as HTMLElement;
      if (!dayCell) return;

      const dayNumber = dayCell.dataset.dayNumber;
      dayCell.innerHTML = '';
      dayCell.classList.remove('timeline-view');
      dayCell.classList.add('has-movies');
      dayCell.style.height = '';

      const dayNumDiv = document.createElement('div');
      dayNumDiv.className = 'day-number';
      dayNumDiv.textContent = dayNumber || '';
      dayCell.appendChild(dayNumDiv);

      if (filteredMovies.length === 0) {
        dayCell.classList.remove('has-movies');
        return;
      }

      if (timelineMode) {
        // Use the pre-calculated week time range for this day
        const weekRange = weekRangesByDate.get(date);
        let dayHeight = MIN_TIMELINE_HEIGHT + TIMELINE_PADDING;
        let dayStartTime = 0;

        if (weekRange && weekRange.range > 0) {
          dayHeight = Math.max(weekRange.range * PX_PER_MIN, MIN_TIMELINE_HEIGHT) + TIMELINE_PADDING;
          dayStartTime = weekRange.start;
        } else {
          // Defensive fallback: calculate day's own range if weekRange is missing
          // (should not occur in practice - all dates from generateDateRange should have weekRange)
          // Note: We know filteredMovies.length > 0 here due to early return above when filteredMovies is empty
          const dayRange = getDayTimeRange(filteredMovies);
          dayHeight = Math.max(dayRange.range * PX_PER_MIN, MIN_TIMELINE_HEIGHT) + TIMELINE_PADDING;
          dayStartTime = dayRange.start;
        }

        dayCell.style.height = `${dayHeight}px`;
        dayCell.classList.add('timeline-view');
        assignOverlapColumns(filteredMovies).forEach(movie => {
          const start = parseTimeToMins(movie.Time);
          const runtime = parseInt(movie.runtime || '90');
          const topPx = (start - dayStartTime) * PX_PER_MIN;
          const heightPx = Math.max(runtime * PX_PER_MIN, 24);
          dayCell.appendChild(createMovieElement(movie, {
            isTimeline: true, topPx, heightPx,
            filteredCounts: filteredShowtimeCounts,
            singleShowtimeMode: singleShowtimesMode
          }));
        });
      } else {
        filteredMovies.forEach(movie => {
          dayCell.appendChild(createMovieElement(movie, {
            isTimeline: false,
            filteredCounts: filteredShowtimeCounts,
            singleShowtimeMode: singleShowtimesMode
          }));
        });
      }
    });
  }

  // --- Control event handlers ---
  document.getElementById('week-start-toggle')?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    document.body.classList.toggle('monday-start', checked);
    document.body.classList.toggle('sunday-start', !checked);
    updateUrlParams();
    renderCalendar();
    setTimeout(updateTextHeights, 10);
  });

  document.getElementById('timeline-mode-toggle')?.addEventListener('change', () => {
    renderAllDays();
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Fit width switch
  const fitWidthSwitch = document.querySelector('#fit-width-switch input') as HTMLInputElement;
  const showYearDirectorCheckbox = document.getElementById('show-year-director-checkbox') as HTMLInputElement;
  const showRuntimeCheckbox = document.getElementById('show-runtime-checkbox') as HTMLInputElement;
  const showActorsCheckbox = document.getElementById('show-actors-checkbox') as HTMLInputElement;
  const showImageCheckbox = document.getElementById('show-image-checkbox') as HTMLInputElement;

  // Helper to determine if minimum-width mode should be enabled
  // Content mode (fit width OFF) always enforces 640px minimum width
  function shouldEnableMinimumWidth(): boolean {
    const fitWidth = fitWidthSwitch?.checked ?? true;
    return !fitWidth;  // If NOT fit width (Content mode), always enforce minimum width
  }

  // Fit width switch — only manages minimum-width class + URL
  // The toolbar owns Fit↔Content↔Detail coordination
  fitWidthSwitch?.addEventListener('change', () => {
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
  });

  // Year/Director checkbox
  showYearDirectorCheckbox?.addEventListener('change', (e) => {
    document.body.classList.toggle('show-year-director', (e.target as HTMLInputElement).checked);
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Runtime checkbox
  showRuntimeCheckbox?.addEventListener('change', (e) => {
    document.body.classList.toggle('show-runtime', (e.target as HTMLInputElement).checked);
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Actors checkbox
  showActorsCheckbox?.addEventListener('change', (e) => {
    document.body.classList.toggle('show-actors', (e.target as HTMLInputElement).checked);
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Image checkbox
  showImageCheckbox?.addEventListener('change', (e) => {
    const checked = (e.target as HTMLInputElement).checked;
    document.body.classList.toggle('show-image', checked);
    document.body.classList.toggle('scrim-enabled', checked);
    document.body.classList.toggle('blur-enabled', checked);
    document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // Time category filter checkboxes
  document.querySelectorAll('input[name="time-filter"]').forEach(checkbox => {
    checkbox.addEventListener('change', () => { renderAllDays(); updateUrlParams(); setTimeout(updateTextHeights, 10); });
  });

  document.querySelectorAll('input[name="saved-filter"]').forEach(checkbox => {
    checkbox.addEventListener('change', () => { renderAllDays(); updateUrlParams(); setTimeout(updateTextHeights, 10); });
  });

  // Highlight unique toggle
  document.querySelector('#highlight-unique-toggle input')?.addEventListener('change', () => {
    renderAllDays();
    updateUrlParams();
    setTimeout(updateTextHeights, 10);
  });

  // --- Load data and render ---
  const movies: Movie[] = window.__movieData;
  allMovies = movies;
  movies.forEach(movie => {
    const date = movie.Datetime.split('T')[0];
    if (!moviesByDate[date]) moviesByDate[date] = [];
    moviesByDate[date].push(movie);
    movieByKey.set(`${movie.Datetime}_${movie.Movie}`, movie);
  });

  allMovieDates = Object.keys(moviesByDate);

  // If user has no reactions, check all saved filter boxes (show everything)
  if (!hasAnyReactions(currentReactions)) {
    document.querySelectorAll<HTMLInputElement>('input[name="saved-filter"]').forEach(cb => {
      cb.checked = true;
    });
  }

  /** Update saved filter button labels with counts */
  function updateSavedFilterCounts() {
    // Get unique movies by film_slug
    const uniqueSlugs = new Set(allMovies.map(m => m.film_slug));
    const counts = { yes: 0, maybe: 0, no: 0, unmarked: 0 };

    uniqueSlugs.forEach(slug => {
      const reaction = currentReactions[slug] || 'none';
      if (reaction === 'yes') counts.yes++;
      else if (reaction === 'maybe') counts.maybe++;
      else if (reaction === 'no') counts.no++;
      else counts.unmarked++;
    });

    // Update the .btn-label span inside each saved filter button
    const updateButton = (btn: Element | null, label: string) => {
      const span = btn?.querySelector('.btn-label');
      if (span) span.textContent = label;
    };

    updateButton(document.querySelector('[data-filter="yes"]'), `Yes (${counts.yes})`);
    updateButton(document.querySelector('[data-filter="maybe"]'), `Maybe (${counts.maybe})`);
    updateButton(document.querySelector('[data-filter="no"]'), `No (${counts.no})`);
    updateButton(document.querySelector('[data-filter="unmarked"]'), `Unmarked (${counts.unmarked})`);
  }

  updateSavedFilterCounts();

  /** Compute and display showtime counts for each time category */
  function updateTimeCategoryCounts() {
    const counts = { weekdays: 0, weeknights: 0, weekends: 0 };

    allMovies.forEach(movie => {
      const date = movie.Datetime.split('T')[0];
      const category = classifyTimeCategory(movie, date);
      counts[category]++;
    });

    Object.entries(counts).forEach(([category, count]) => {
      const el = document.querySelector(`.filter-count[data-count-for="${category}"]`);
      if (el) el.textContent = `(${count})`;
    });
  }

  updateTimeCategoryCounts();

  // Restore URL state silently before first render (no events, no re-renders)
  restoreFromUrl();

  // Signal toolbar to sync its button states from the restored checkboxes
  document.dispatchEvent(new Event('url-state-restored'));

  // Initialize minimum-width class based on fit-width switch and tile display options
  document.body.classList.toggle('minimum-width', shouldEnableMinimumWidth());

  // Single render with all state already applied
  renderCalendar();
  setTimeout(updateTextHeights, 10);

  // --- Width mode: Fit vs Content ---
  // Fit = fit to window width (no minimum)
  // Content = enforce 640px minimum width ALWAYS (enables horizontal scroll when needed)

  // --- DOMContentLoaded: event delegation ---
  document.addEventListener('DOMContentLoaded', () => {

    // Pointer device detection
    if (window.matchMedia('(hover: hover) and (pointer: fine)').matches) {
      document.querySelectorAll('.desktop-only').forEach(el => el.classList.add('has-pointer'));
    }

    // Movie tile click → modal
    function getMovieFromEl(el: Element): Movie | undefined {
      return movieByKey.get((el as HTMLElement).dataset.movieKey || '');
    }

    document.querySelector('.calendar')?.addEventListener('click', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-key]');
      if (movieEl) {
        const movie = getMovieFromEl(movieEl);
        if (movie) openMovieModal(movie);
      }
    });

    document.querySelector('.calendar')?.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        const movieEl = (e.target as HTMLElement).closest('[data-movie-key]');
        if (movieEl) {
          e.preventDefault();
          const movie = getMovieFromEl(movieEl);
          if (movie) openMovieModal(movie);
        }
      }
    });

    // Highlight alternate showtimes on hover
    let currentHighlightedMovie: string | null = null;

    document.querySelector('.calendar')?.addEventListener('mouseover', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-title]');
      if (!movieEl) return;

      const highlightToggleEl = document.getElementById('highlight-alternate-toggle');
      const highlightEnabled = highlightToggleEl?.tagName === 'INPUT'
        ? (highlightToggleEl as HTMLInputElement).checked
        : (highlightToggleEl?.querySelector('input') as HTMLInputElement)?.checked;
      if (!highlightEnabled) return;

      const movieTitle = (movieEl as HTMLElement).dataset.movieTitle!;

      let visibleCount = 0;
      document.querySelectorAll('[data-movie-title]').forEach(el => {
        if ((el as HTMLElement).dataset.movieTitle === movieTitle) visibleCount++;
      });
      if (visibleCount <= 1) return;

      if (currentHighlightedMovie === movieTitle) return;
      currentHighlightedMovie = movieTitle;

      document.querySelectorAll('.alternate-highlight').forEach(el => el.classList.remove('alternate-highlight'));
      document.querySelectorAll('[data-movie-title]').forEach(el => {
        if ((el as HTMLElement).dataset.movieTitle === movieTitle) el.classList.add('alternate-highlight');
      });
    });

    document.querySelector('.calendar')?.addEventListener('mouseout', (e) => {
      const movieEl = (e.target as HTMLElement).closest('[data-movie-title]');
      const relatedTarget = (e as MouseEvent).relatedTarget as HTMLElement | null;
      const relatedMovieEl = relatedTarget?.closest('[data-movie-title]');

      if (movieEl && (!relatedMovieEl || relatedMovieEl !== movieEl)) {
        currentHighlightedMovie = null;
        document.querySelectorAll('.alternate-highlight').forEach(el => el.classList.remove('alternate-highlight'));
      }
    });
  });
</script>

<style>
  /* Calendar scroll container - only scrolls horizontally in minimum-width mode */
  .calendar-scroll-container {
    width: 100%;
  }

  :global(body.minimum-width) .calendar-scroll-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* Day number styles (for dynamically recreated elements) */
  :global(.day-number) {
    font-size: 14px;
    line-height: 1;
    font-weight: 300;
    color: var(--text-tertiary);
    margin-bottom: 8px;
    padding-left: 4px;
    font-family: 'Barlow Condensed', sans-serif;
    text-transform: uppercase;
    letter-spacing: -0.015em;
  }

  @media (min-width: 480px) {
    :global(.day-number) {
      font-size: 13px;
      font-family: 'Barlow Semi Condensed', sans-serif;
      letter-spacing: -0.01em;
    }
  }

  @media (min-width: 640px) {
    :global(.day-number) {
      font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      text-transform: none;
      letter-spacing: normal;
      font-weight: 400;
    }
  }

  :global(.day.has-movies .day-number) {
    color: var(--text-secondary);
  }

  :global(.day.timeline-view .day-number) {
    position: absolute;
    top: 4px;
    left: 4px;
    z-index: 20;
    margin-bottom: 0;
  }

  @media (min-width: 768px) {
    :global(body.show-image .day-number) {
      font-weight: 500;
    }

    :global(.day-number) {
      padding-left: 6px;
    }
  }

  @media (min-width: 1024px) {
    :global(.day-number) {
      padding-left: 10px;
    }
  }

  /* Hidden movies list content styles */
  :global(.hidden-movies-list) {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  :global(.hidden-movie-item) {
    padding: 4px 0;
    border-bottom: 1px solid var(--bg-movie);
  }

  :global(.hidden-movie-item:last-child) {
    border-bottom: none;
  }

  :global(.hidden-movie-title) {
    font-weight: 500;
    color: var(--text-primary);
    display: inline;
  }

  :global(.hidden-movie-meta) {
    font-size: 12px;
    color: var(--text-tertiary);
    display: inline;
    margin-left: 6px;
  }

  :global(.hidden-movie-showtimes) {
    display: inline;
    margin-left: 6px;
    font-size: 12px;
    color: var(--text-tertiary);
  }

  :global(.hidden-showtime) {
    color: var(--text-secondary);
  }

  :global(.hidden-showtime:not(:last-child)::after) {
    content: ', ';
  }

</style>
