---
import Layout from '@layouts/Layout.astro';
import ListToolbar from '@components/session/ListToolbar.astro';
import MovieListItem from '@components/session/MovieListItem.astro';
import MovieCard from '@components/session/MovieCard.astro';
import BottomToolbar from '@components/session/BottomToolbar.astro';
import MovieDetailDrawer from '@components/session/MovieDetailDrawer.astro';
import SingleCardView from '@components/session/SingleCardView.astro';
import type { Movie } from '@utils/movieUtils';
import { toTitleCase, formatRuntime } from '@utils/movieUtils';
import { getAllSeriesIds, getSeriesConfig } from '@config/series';
import {
  deduplicateMovies,
  sortMovies,
} from '@utils/sessionUtils';

export function getStaticPaths() {
  return getAllSeriesIds().map(id => ({ params: { id } }));
}

const { id } = Astro.params;
const config = getSeriesConfig(id!);
if (!config) return Astro.redirect('/');

// Load movie data at build time from public directory
let allMovies: Movie[] = [];
try {
  const fs = await import('node:fs');
  const path = await import('node:path');
  const dataPath = path.join(process.cwd(), 'public', config.dataFile);
  const data = fs.readFileSync(dataPath, 'utf-8');
  allMovies = JSON.parse(data);
} catch {
  allMovies = [];
}

const uniqueMovies = sortMovies(deduplicateMovies(allMovies), 'alpha');

// Extract unique directors, actors, and decades for filter dropdowns
const directorsSet = new Set<string>();
const actorsSet = new Set<string>();
const decadesSet = new Set<string>();

for (const um of uniqueMovies) {
  const m = um.movie;
  if (m.director) directorsSet.add(m.director);
  if (m.actors) {
    for (const actor of m.actors.split(', ')) {
      const trimmed = actor.trim();
      if (trimmed) actorsSet.add(trimmed);
    }
  }
  if (m.year) {
    const decade = Math.floor(parseInt(m.year) / 10) * 10;
    if (!isNaN(decade)) decadesSet.add(`${decade}s`);
  }
}

const directors = [...directorsSet].sort((a, b) => a.localeCompare(b));
const actors = [...actorsSet].sort((a, b) => a.localeCompare(b));
const decades = [...decadesSet].sort();

// Serialize movie data for client-side use
const movieDataJson = JSON.stringify(uniqueMovies);

// SEO metadata
const title = `${config.name} Movie List - Browse ${uniqueMovies.length} Films`;
const description = `Browse all ${uniqueMovies.length} films in ${config.name}. Mark your favorites (Yes/Maybe/No), create a shareable list, and plan your ${config.venueName} visits.`;
const canonical = `/s/${id}/list`;
const ogImage = allMovies[0]?.poster_url || null;

// Structured data for movie list
const structuredData = {
  "@context": "https://schema.org",
  "@type": "ItemList",
  "name": `${config.name} - Movie List`,
  "numberOfItems": uniqueMovies.length,
  "itemListElement": uniqueMovies.slice(0, 20).map((um, index) => ({
    "@type": "Movie",
    "position": index + 1,
    "name": toTitleCase(um.movie.Movie),
    "director": um.movie.director ? toTitleCase(um.movie.director) : undefined,
    "datePublished": um.movie.year,
  }))
};
---

<Layout
  title={title}
  description={description}
  canonical={canonical}
  ogImage={ogImage}
  ogImageAlt={`${config.name} movie list`}
  structuredData={structuredData}
>
  <div data-session-id={id} data-drawer-wrapper>
    <header class="page-header">
      <a href={`/s/${id}`} class="back-link">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
          <path d="M10 3L5 8l5 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        Back
      </a>
      <h1 class="page-title">{config.name}</h1>
      {config.subtitle && <p class="page-subtitle">{config.subtitle}</p>}
      <p class="page-movie-count" id="page-movie-count">{uniqueMovies.length} films</p>
    </header>

    <ListToolbar directors={directors} actors={actors} decades={decades} />

    <!-- List view -->
    <div class="movie-list-view" id="list-view" style="display: none;">
      {uniqueMovies.map(um => (
        <MovieListItem uniqueMovie={um} />
      ))}
    </div>

    <!-- Card view (default) -->
    <div class="movie-card-grid" id="card-view">
      {uniqueMovies.map(um => (
        <MovieCard uniqueMovie={um} />
      ))}
    </div>

    <!-- Single card view (Apple-style drawer) -->
    <SingleCardView movies={uniqueMovies} hidden={true} />

    <!-- Spacer for bottom toolbar -->
    <div class="bottom-spacer"></div>

    <BottomToolbar sessionId={id!} />
    <MovieDetailDrawer />
  </div>
</Layout>

<script define:vars={{ movieDataJson, sessionId: id }}>
  window.__movieData = JSON.parse(movieDataJson);
  window.__sessionId = sessionId;
</script>

<script>
  import { getReactions, setReaction, getReactionCounts } from '@utils/storageManager';
  import { toTitleCase, formatRuntime } from '@utils/movieUtils';
  import { sortMovies } from '@utils/sessionUtils';
  import type { MovieReaction, UniqueMovie } from '@types/session';

  const sessionId = (window as any).__sessionId as string;
  const allMovies = (window as any).__movieData as UniqueMovie[];

  // --- State ---
  let currentView: 'list' | 'card' | 'single' = 'card';
  let currentSort = 'alpha';
  let currentDetailIndex = 0;

  // --- DOM references ---
  const listView = document.getElementById('list-view')!;
  const cardView = document.getElementById('card-view')!;
  const singleViewWrapper = document.getElementById('single-view-wrapper');
  const badge = document.querySelector('.saved-badge') as HTMLElement;

  // --- Initialize reactions from localStorage ---
  function loadReactions() {
    const reactions = getReactions(sessionId);
    // Update all reaction buttons on the page
    document.querySelectorAll('[data-movie-id][data-reaction]').forEach(btn => {
      const movieId = (btn as HTMLElement).dataset.movieId!;
      const btnReaction = (btn as HTMLElement).dataset.reaction!;
      const currentReaction = reactions[movieId] || 'none';
      const isActive = btnReaction === currentReaction;
      btn.classList.toggle('active', isActive);
      (btn as HTMLElement).setAttribute('aria-pressed', String(isActive));
    });

    // Update card/list item states
    document.querySelectorAll('.card[data-movie-id], .list-item[data-movie-id]').forEach(el => {
      const movieId = (el as HTMLElement).dataset.movieId!;
      const reaction = reactions[movieId] || 'none';
      (el as HTMLElement).dataset.reaction = reaction;
      // Remove old reaction classes
      el.classList.remove('card--yes', 'card--maybe', 'card--no', 'list-item--yes', 'list-item--maybe', 'list-item--no');
      if (reaction !== 'none') {
        const prefix = el.classList.contains('card') ? 'card' : 'list-item';
        el.classList.add(`${prefix}--${reaction}`);
      }
    });

    updateBadge();
  }

  function updateBadge() {
    const counts = getReactionCounts(sessionId);
    const total = counts.yes + counts.maybe + counts.no;
    if (badge) {
      badge.textContent = String(total);
      badge.dataset.count = String(total);
      // Trigger bump animation
      badge.classList.remove('bump');
      void badge.offsetWidth; // Force reflow
      badge.classList.add('bump');
    }
  }

  // --- Reaction button handling ---
  document.addEventListener('click', (e) => {
    const btn = (e.target as HTMLElement).closest('.reaction-btn, .rbtn, .detail-rbtn') as HTMLElement | null;
    if (!btn) return;

    const movieId = btn.dataset.movieId;
    const reaction = btn.dataset.reaction as MovieReaction;
    if (!movieId || !reaction) return;

    const reactions = getReactions(sessionId);
    const current = reactions[movieId] || 'none';

    // Toggle: if same reaction, clear it; otherwise set new
    const newReaction: MovieReaction = current === reaction ? 'none' : reaction;
    setReaction(sessionId, movieId, newReaction);

    // Immediate visual feedback before full DOM sync
    const card = document.querySelector(`.card[data-movie-id="${movieId}"]`) as HTMLElement;
    if (card) {
      card.classList.remove('card--yes', 'card--maybe', 'card--no');
      if (newReaction !== 'none') card.classList.add(`card--${newReaction}`);
    }

    // Update detail drawer buttons immediately
    document.querySelectorAll(`#detail-reactions .detail-rbtn[data-movie-id="${movieId}"]`).forEach(b => {
      const r = (b as HTMLElement).dataset.reaction;
      b.classList.toggle('active', r === newReaction);
    });

    loadReactions();
  });

  // Handle reactions from SingleCardView drawer
  document.addEventListener('single-card-reaction', ((e: CustomEvent) => {
    const { movieId, reaction } = e.detail;
    if (movieId) {
      setReaction(sessionId, movieId, reaction as MovieReaction);
      loadReactions();
    }
  }) as EventListener);

  // --- View toggle ---
  document.querySelectorAll('.view-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const view = (btn as HTMLElement).dataset.view as 'list' | 'card' | 'single';
      if (view === currentView) return;
      currentView = view;

      document.querySelectorAll('.view-btn').forEach(b => {
        b.classList.toggle('active', (b as HTMLElement).dataset.view === view);
        (b as HTMLElement).setAttribute('aria-checked', String((b as HTMLElement).dataset.view === view));
      });

      listView.style.display = view === 'list' ? '' : 'none';
      cardView.style.display = view === 'card' ? '' : 'none';

      // Single view: open the Apple-style drawer
      const ctrl = (window as any).singleCardController;
      if (view === 'single' && ctrl) {
        ctrl.open();
      } else if (ctrl) {
        ctrl.close();
      }
    });
  });

  // --- Sort ---
  document.getElementById('sort-select')?.addEventListener('change', (e) => {
    currentSort = (e.target as HTMLSelectElement).value;
    const reactions = getReactions(sessionId);
    const sorted = sortMovies([...allMovies], currentSort, reactions);
    reorderMovies(sorted);
  });

  function reorderMovies(sorted: UniqueMovie[]) {
    // Reorder list view
    const listItems = listView.querySelectorAll('.list-item');
    const listMap = new Map<string, HTMLElement>();
    listItems.forEach(el => {
      const id = (el as HTMLElement).dataset.movieId!;
      listMap.set(id, el as HTMLElement);
    });
    sorted.forEach(m => {
      const el = listMap.get(m.id);
      if (el) listView.appendChild(el);
    });

    // Reorder card view
    const cards = cardView.querySelectorAll('.card');
    const cardMap = new Map<string, HTMLElement>();
    cards.forEach(el => {
      const id = (el as HTMLElement).dataset.movieId!;
      cardMap.set(id, el as HTMLElement);
    });
    sorted.forEach(m => {
      const el = cardMap.get(m.id);
      if (el) cardView.appendChild(el);
    });
  }

  // --- Search & Filter ---
  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const searchClear = document.getElementById('search-clear') as HTMLElement;
  const filterDirector = document.getElementById('filter-director') as HTMLSelectElement;
  const filterActor = document.getElementById('filter-actor') as HTMLSelectElement;
  const filterDecade = document.getElementById('filter-decade') as HTMLSelectElement;
  const filterResults = document.getElementById('filter-results') as HTMLElement;
  const filterResultsText = document.getElementById('filter-results-text') as HTMLElement;
  const filterClearAll = document.getElementById('filter-clear-all') as HTMLElement;
  const movieCount = document.getElementById('page-movie-count') as HTMLElement;
  const totalCount = allMovies.length;

  function getDecade(year: string): string {
    const y = parseInt(year);
    if (isNaN(y)) return '';
    return `${Math.floor(y / 10) * 10}s`;
  }

  function applyFilters() {
    const query = searchInput?.value.toLowerCase().trim() || '';
    const director = filterDirector?.value || '';
    const actor = filterActor?.value || '';
    const decade = filterDecade?.value || '';

    const hasFilters = query || director || actor || decade;

    // Show/hide clear button on search input
    if (searchClear) {
      searchClear.style.display = query ? '' : 'none';
    }

    // Highlight active filter selects
    filterDirector?.classList.toggle('active-filter', !!director);
    filterActor?.classList.toggle('active-filter', !!actor);
    filterDecade?.classList.toggle('active-filter', !!decade);

    let visibleCount = 0;

    // Filter cards and list items by matching data attributes
    const selectors = '.card[data-movie-id], .list-item[data-movie-id]';
    document.querySelectorAll(selectors).forEach(el => {
      const htmlEl = el as HTMLElement;
      const elTitle = htmlEl.dataset.title || '';
      const elDirector = htmlEl.dataset.director || '';
      const elActors = htmlEl.dataset.actors || '';
      const elYear = htmlEl.dataset.year || '';
      const elDecade = getDecade(elYear);
      const movieId = htmlEl.dataset.movieId || '';

      let visible = true;

      // Text search: matches title, director, or actors
      if (query) {
        const matchesSearch = elTitle.includes(query) ||
          elDirector.includes(query) ||
          elActors.includes(query);
        if (!matchesSearch) visible = false;
      }

      // Director filter
      if (director && elDirector !== director) {
        visible = false;
      }

      // Actor filter: check if the selected actor appears in the actors list
      if (actor && !elActors.includes(actor)) {
        visible = false;
      }

      // Decade filter
      if (decade && elDecade !== decade) {
        visible = false;
      }

      htmlEl.style.display = visible ? '' : 'none';

      // Count unique visible movies (count cards only to avoid double-counting)
      if (visible && htmlEl.classList.contains('card')) {
        visibleCount++;
      }
    });

    // Update movie count display
    if (movieCount) {
      if (hasFilters) {
        movieCount.textContent = `${visibleCount} of ${totalCount} films`;
      } else {
        movieCount.textContent = `${totalCount} films`;
      }
    }

    // Show/hide filter results bar
    if (filterResults) {
      if (hasFilters) {
        filterResults.style.display = '';
        filterResultsText.textContent = `${visibleCount} of ${totalCount}`;
      } else {
        filterResults.style.display = 'none';
      }
    }
  }

  function clearAllFilters() {
    if (searchInput) searchInput.value = '';
    if (filterDirector) filterDirector.value = '';
    if (filterActor) filterActor.value = '';
    if (filterDecade) filterDecade.value = '';
    applyFilters();
  }

  // Debounce search input
  let searchTimeout: ReturnType<typeof setTimeout>;
  searchInput?.addEventListener('input', () => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(applyFilters, 150);
  });

  searchClear?.addEventListener('click', () => {
    if (searchInput) searchInput.value = '';
    applyFilters();
  });

  filterDirector?.addEventListener('change', applyFilters);
  filterActor?.addEventListener('change', applyFilters);
  filterDecade?.addEventListener('change', applyFilters);
  filterClearAll?.addEventListener('click', clearAllFilters);

  // --- More Info Drawer ---
  function openMovieDetail(movieId: string, sourceEl?: HTMLElement) {
    const idx = allMovies.findIndex(m => m.id === movieId);
    if (idx === -1) return;

    // Use Apple-style drawer for card taps
    const ctrl = (window as any).singleCardController;
    if (ctrl) {
      ctrl.reactions = getReactions(sessionId);
      ctrl.open(idx, sourceEl);
    } else {
      showMovieDetail(idx);
      (window as any).openDrawer('movie-detail-drawer');
    }
  }

  function showMovieDetail(index: number) {
    currentDetailIndex = index;
    const um = allMovies[index];
    if (!um) return;

    const { movie, id } = um;
    const reactions = getReactions(sessionId);
    const reaction = reactions[id] || 'none';

    // Update poster
    const img = document.getElementById('detail-poster-img') as HTMLImageElement;
    if (img) {
      img.src = movie.poster_url || '';
      img.alt = movie.Movie;
    }

    // Update text
    const titleEl = document.getElementById('detail-title');
    if (titleEl) titleEl.textContent = toTitleCase(movie.Movie);

    const metaEl = document.getElementById('detail-meta');
    if (metaEl) metaEl.textContent = [movie.director, movie.year, formatRuntime(movie.runtime)].filter(Boolean).join(' · ');

    const actorsEl = document.getElementById('detail-actors');
    if (actorsEl) actorsEl.textContent = movie.actors || '';

    const descEl = document.getElementById('detail-description');
    if (descEl) descEl.textContent = movie.description || '';

    // Update links
    const filmUrl = document.getElementById('detail-film-url') as HTMLAnchorElement;
    if (filmUrl) {
      filmUrl.href = movie.film_url || '#';
      filmUrl.style.display = movie.film_url ? '' : 'none';
    }

    const ticketsUrl = document.getElementById('detail-tickets-url') as HTMLAnchorElement;
    if (ticketsUrl) {
      // Use first showtime's ticket URL
      ticketsUrl.href = um.showtimes[0]?.tickets || '#';
      ticketsUrl.style.display = um.showtimes[0]?.tickets ? '' : 'none';
    }

    // Update detail drawer reaction buttons
    document.querySelectorAll('#detail-reactions .detail-rbtn').forEach(btn => {
      (btn as HTMLElement).dataset.movieId = id;
      const btnReaction = (btn as HTMLElement).dataset.reaction;
      btn.classList.toggle('active', btnReaction === reaction);
      (btn as HTMLElement).setAttribute('aria-pressed', String(btnReaction === reaction));
    });
  }

  // More info click handlers — info button or tapping the item itself
  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;

    // Skip if clicking a reaction button
    if (target.closest('.reaction-btn')) return;

    // Info button click
    const infoBtn = target.closest('[data-action="more-info"]') as HTMLElement | null;
    if (infoBtn) {
      const movieId = infoBtn.dataset.movieId;
      if (movieId) openMovieDetail(movieId);
      return;
    }

    // Click on a card or list item body (not on buttons)
    const item = target.closest('.card, .list-item') as HTMLElement | null;
    if (item && !target.closest('button, a')) {
      const movieId = item.dataset.movieId;
      const sourceCard = item.classList.contains('card') ? item : undefined;
      if (movieId) openMovieDetail(movieId, sourceCard);
    }
  });

  // --- Initialize ---
  loadReactions();
</script>

<style>
  .page-header {
    padding: 16px 4px 12px;
  }

  .back-link {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 13px;
    color: var(--text-secondary);
    text-decoration: none;
    margin-bottom: 8px;
    transition: color 0.15s;
  }

  .back-link:hover {
    color: var(--accent);
  }

  .page-title {
    font-size: 24px;
    font-weight: 700;
    color: var(--text-primary);
    margin: 0;
    line-height: 1.2;
  }

  .page-subtitle {
    font-size: 15px;
    color: var(--text-secondary);
    margin: 4px 0 0 0;
    font-style: italic;
  }

  .page-movie-count {
    font-size: 13px;
    color: var(--text-tertiary);
    margin: 4px 0 0 0;
  }

  /* List view */
  .movie-list-view {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  /* Card grid */
  .movie-card-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
  }

  @media (max-width: 480px) {
    .movie-card-grid {
      grid-template-columns: 1fr;
    }
  }

  /* Spacer for fixed bottom toolbar */
  .bottom-spacer {
    height: 80px;
  }
</style>
