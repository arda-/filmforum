---
/**
 * Composable tooltip component.
 * Wraps any trigger element and shows a tooltip on hover.
 *
 * Usage:
 * <Tooltip text="Your tooltip text">
 *   <button>Hover me</button>
 * </Tooltip>
 */
interface Props {
  text: string;
  disabled?: boolean;
}

const { text, disabled = false } = Astro.props;
---

<span class="tooltip-wrapper" data-tooltip={text} data-disabled={disabled}>
  <slot />
</span>

<script>
  // Initialize tooltips
  function initTooltips() {
    const wrappers = document.querySelectorAll('.tooltip-wrapper');

    wrappers.forEach(wrapper => {
      if (wrapper.hasAttribute('data-tooltip-init')) return;
      wrapper.setAttribute('data-tooltip-init', '');

      let tooltipEl: HTMLElement | null = null;
      let showTimeout: number | null = null;
      let hideTimeout: number | null = null;

      const show = () => {
        const isDisabled = wrapper.getAttribute('data-disabled') === 'true';
        if (isDisabled) return;

        if (hideTimeout) {
          clearTimeout(hideTimeout);
          hideTimeout = null;
        }

        showTimeout = window.setTimeout(() => {
          const text = wrapper.getAttribute('data-tooltip');
          if (!text) return;

          tooltipEl = document.createElement('div');
          tooltipEl.className = 'tooltip-content';
          tooltipEl.textContent = text;
          tooltipEl.setAttribute('role', 'tooltip');
          document.body.appendChild(tooltipEl);

          const rect = wrapper.getBoundingClientRect();
          const tooltipRect = tooltipEl.getBoundingClientRect();

          // Position above the element, centered
          let left = rect.left + rect.width / 2 - tooltipRect.width / 2;
          let top = rect.top - tooltipRect.height - 8;

          // Keep within viewport bounds
          const padding = 8;
          if (left < padding) left = padding;
          if (left + tooltipRect.width > window.innerWidth - padding) {
            left = window.innerWidth - tooltipRect.width - padding;
          }
          if (top < padding) {
            // Show below if no room above
            top = rect.bottom + 8;
          }

          tooltipEl.style.left = `${left}px`;
          tooltipEl.style.top = `${top}px`;

          requestAnimationFrame(() => {
            tooltipEl?.classList.add('visible');
          });
        }, 300);
      };

      const hide = () => {
        if (showTimeout) {
          clearTimeout(showTimeout);
          showTimeout = null;
        }

        if (tooltipEl) {
          tooltipEl.classList.remove('visible');
          hideTimeout = window.setTimeout(() => {
            tooltipEl?.remove();
            tooltipEl = null;
          }, 150);
        }
      };

      // Only show tooltips on hover for devices that support it
      if (window.matchMedia('(hover: hover)').matches) {
        wrapper.addEventListener('mouseenter', show);
        wrapper.addEventListener('mouseleave', hide);
      }
      wrapper.addEventListener('focus', show, true);
      wrapper.addEventListener('blur', hide, true);
    });
  }

  // Init on load and after dynamic content changes
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initTooltips);
  } else {
    initTooltips();
  }
</script>

<style>
  .tooltip-wrapper {
    display: inline-flex;
    position: relative;
  }

  :global(.tooltip-content) {
    position: fixed;
    z-index: calc(var(--z-drawer-bg) + 2);
    padding: 6px 10px;
    font-size: 12px;
    line-height: 1.4;
    color: var(--text-primary);
    background: var(--bg-movie);
    border: 1px solid var(--bg-movie-hover);
    border-radius: 6px;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s ease;
    max-width: 240px;
    word-wrap: break-word;
  }

  :global(.tooltip-content.visible) {
    opacity: 1;
  }

  @media (prefers-reduced-motion: reduce) {
    :global(.tooltip-content) {
      transition: none;
    }
  }
</style>
