---
/**
 * Vaul-style drawer component.
 * Slides up from bottom with backdrop, swipe-to-dismiss, and smooth transitions.
 *
 * @slot default - Main body content.
 * @slot close - Close button. Defaults to a floating frosted-glass X button.
 *   Custom replacements should include `data-drawer-close` on clickable elements
 *   so the built-in close handler fires.
 * @slot footer - Optional sticky footer (e.g. action buttons). When present,
 *   safe-area inset padding shifts from the body to the footer.
 */
import Icon from './Icon.astro';

interface Props {
  id: string;
  title?: string;
  height?: string;
  /** @deprecated Use `height` instead */
  maxHeight?: string;
}

const { id, title, height, maxHeight } = Astro.props;
const resolvedHeight = height ?? maxHeight ?? '85dvh';
const hasFooter = Astro.slots.has('footer');
---

<div id={id} class="drawer" data-open="false" role="dialog" aria-modal="true" aria-labelledby={title ? `${id}-title` : undefined}>
  <div class="drawer-backdrop" data-drawer-close></div>
  <div class="drawer-container" style={`--drawer-height: ${resolvedHeight}`} data-has-footer={hasFooter ? '' : undefined}>
    <div class="drawer-handle-area" data-drawer-handle>
      <div class="drawer-handle"></div>
    </div>
    <slot name="close">
      <button class="drawer-close-btn" data-drawer-close aria-label="Close">
        <Icon name="x" size={18} />
      </button>
    </slot>
    {title && (
      <div class="drawer-header">
        <h2 id={`${id}-title`} class="drawer-title">{title}</h2>
      </div>
    )}
    <div class="drawer-body">
      <slot />
    </div>
    {hasFooter && (
      <div class="drawer-footer">
        <slot name="footer" />
      </div>
    )}
  </div>
</div>

<style>
  .drawer {
    display: none;
    position: fixed;
    inset: 0;
    z-index: var(--z-drawer);
  }

  .drawer[data-open="true"] {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }

  .drawer-backdrop {
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    animation: drawer-backdrop-in 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  }

  .drawer[data-open="true"] .drawer-container {
    animation: drawer-slide-up 0.3s cubic-bezier(0.32, 0.72, 0, 1);
  }

  .drawer.closing .drawer-backdrop {
    animation: drawer-backdrop-out 0.25s cubic-bezier(0.32, 0.72, 0, 1) forwards;
  }

  .drawer.closing .drawer-container {
    animation: drawer-slide-down 0.25s cubic-bezier(0.32, 0.72, 0, 1) forwards;
  }

  @keyframes drawer-backdrop-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes drawer-backdrop-out {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  @keyframes drawer-slide-up {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }

  @keyframes drawer-slide-down {
    from { transform: translateY(0); }
    to { transform: translateY(100%); }
  }

  .drawer-container {
    position: relative;
    z-index: 1;
    height: var(--drawer-height, 85dvh);
    max-height: 100dvh;
    background: var(--bg-day);
    border-radius: 1.5rem 1.5rem 0 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
    will-change: transform;
    outline: none;
  }

  .drawer-handle-area {
    display: flex;
    justify-content: center;
    padding: 12px 0 4px;
    cursor: grab;
    flex-shrink: 0;
  }

  .drawer-handle-area:active {
    cursor: grabbing;
  }

  .drawer-handle {
    width: 36px;
    height: 4px;
    background: var(--bg-movie-hover);
    border-radius: 2px;
  }

  .drawer-close-btn {
    position: absolute;
    top: 12px;
    right: 12px;
    z-index: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 36px;
    height: 36px;
    padding: 0;
    background: color-mix(in srgb, var(--bg-movie-hover) var(--drawer-close-bg-opacity), transparent);
    backdrop-filter: blur(8px);
    -webkit-backdrop-filter: blur(8px);
    border: none;
    border-radius: 50%;
    color: var(--drawer-close-color);
    cursor: pointer;
    outline: none;
    transition: background-color 0.15s, color 0.15s, backdrop-filter 0.15s;
  }

  .drawer-close-btn:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  @media (hover: hover) {
    .drawer-close-btn:hover {
      background: var(--bg-movie-hover);
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      color: var(--text-primary);
    }
  }

  .drawer-header {
    padding: 0 20px 12px;
    padding-right: 48px;
    flex-shrink: 0;
  }

  .drawer-title {
    font-size: 17px;
    font-weight: 600;
    color: var(--text-primary);
    margin: 0;
  }

  .drawer-body {
    overflow-y: auto;
    overscroll-behavior: contain;
    padding: 0 20px 2px;
    flex: 1 1 auto;
    min-height: 0;
    -webkit-overflow-scrolling: touch;
  }

  /* Devices without mobile bottom browser chrome need explicit bottom padding.
     Two cases:
     1. Desktop/laptop with mouse or trackpad (hover + fine pointer)
     2. Touch tablets in full-screen mode (coarse pointer + large viewport) —
        when an iPad enters compact/split-view with bottom chrome, the viewport
        narrows below 768px, correctly skipping this padding. */
  @media (hover: hover) and (pointer: fine),
         (pointer: coarse) and (min-width: 768px) and (min-height: 600px) {
    .drawer-body {
      padding-bottom: 12px;
    }
  }

  /* Body gets safe area padding only when it's the bottom-most element
     (no footer). When a footer exists, it handles the safe area instead. */
  .drawer-container:not([data-has-footer]) .drawer-body {
    padding-bottom: calc(2px + env(safe-area-inset-bottom, 0px));
  }

  .drawer-footer {
    flex-shrink: 0;
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    padding: 12px 20px calc(12px + env(safe-area-inset-bottom, 0px));
    background: var(--bg-day);
    border-top: 1px solid var(--bg-movie-hover);
  }

  @media (hover: hover) and (pointer: fine),
         (pointer: coarse) and (min-width: 768px) and (min-height: 600px) {
    .drawer-footer {
      padding-bottom: 12px;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    .drawer[data-open="true"] .drawer-container,
    .drawer.closing .drawer-container,
    .drawer-backdrop,
    .drawer.closing .drawer-backdrop {
      animation: none;
    }

    .drawer-close-btn {
      transition: none;
    }
  }
</style>

<script>
  // Drawer initialization
  document.querySelectorAll('.drawer').forEach(drawer => {
    const container = drawer.querySelector('.drawer-container') as HTMLElement;
    const handle = drawer.querySelector('[data-drawer-handle]') as HTMLElement;
    const body = drawer.querySelector('.drawer-body') as HTMLElement;

    let startY = 0;
    let currentY = 0;
    let isDragging = false;
    let dragSource: 'handle' | 'body' | null = null;

    function closeDrawer() {
      const trigger = (drawer as any)._triggerElement as HTMLElement | null;
      drawer.classList.add('closing');
      setTimeout(() => {
        (drawer as HTMLElement).dataset.open = 'false';
        drawer.classList.remove('closing');
        container.style.transform = '';
        document.body.style.overflow = '';
        if (trigger && typeof trigger.focus === 'function') trigger.focus();
      }, 250);
    }

    // Close on any element with data-drawer-close (default X button, custom close buttons, backdrop)
    drawer.querySelectorAll('[data-drawer-close]').forEach(el => {
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        closeDrawer();
      });
    });

    // --- Swipe-to-dismiss ---
    function isInsideScrolledContainer(target: EventTarget | null): boolean {
      let el = target as HTMLElement | null;
      while (el && el !== body) {
        if (el.scrollTop > 0) return true;
        el = el.parentElement;
      }
      return body.scrollTop > 0;
    }

    function onTouchStart(e: TouchEvent, source: 'handle' | 'body') {
      // For body drags, only start if no scrollable ancestor is scrolled
      if (source === 'body' && isInsideScrolledContainer(e.target)) return;
      isDragging = true;
      dragSource = source;
      startY = e.touches[0].clientY;
      currentY = 0;
      container.style.transition = 'none';
    }

    function onTouchMove(e: TouchEvent) {
      if (!isDragging) return;
      const delta = e.touches[0].clientY - startY;
      if (delta < 0) {
        // Swiping up — if from body, cancel drag and let scroll take over
        if (dragSource === 'body') {
          isDragging = false;
          container.style.transition = '';
          container.style.transform = '';
          return;
        }
        currentY = 0;
      } else {
        currentY = delta;
        // Prevent native scroll immediately when dragging down
        e.preventDefault();
      }
      container.style.transform = `translateY(${currentY}px)`;
    }

    function onTouchEnd() {
      if (!isDragging) return;
      isDragging = false;
      dragSource = null;
      container.style.transition = '';

      if (currentY > 80) {
        closeDrawer();
      } else {
        container.style.transform = '';
      }
      currentY = 0;
    }

    // Handle area — always draggable
    if (handle) {
      handle.addEventListener('touchstart', (e) => onTouchStart(e, 'handle'), { passive: true });
    }

    // Body area — draggable when at scroll top
    if (body) {
      body.addEventListener('touchstart', (e) => onTouchStart(e, 'body'), { passive: true });
    }

    // Shared move/end — listen on the entire drawer element (not just container)
    // so touches that start on body but move to container are captured
    drawer.addEventListener('touchmove', (e) => onTouchMove(e as TouchEvent), { passive: false });
    drawer.addEventListener('touchend', () => onTouchEnd());

    // Mouse drag support (handle only, for desktop)
    if (handle) {
      handle.addEventListener('mousedown', (e: MouseEvent) => {
        isDragging = true;
        dragSource = 'handle';
        startY = e.clientY;
        container.style.transition = 'none';

        const onMouseMove = (e: MouseEvent) => {
          if (!isDragging) return;
          currentY = e.clientY - startY;
          if (currentY < 0) currentY = 0;
          container.style.transform = `translateY(${currentY}px)`;
        };

        const onMouseUp = () => {
          isDragging = false;
          dragSource = null;
          container.style.transition = '';
          if (currentY > 80) {
            closeDrawer();
          } else {
            container.style.transform = '';
          }
          currentY = 0;
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });
    }
  });

  // Delegated keyboard handler — single listener for Escape + focus trap
  // across all drawer instances (avoids per-drawer listener accumulation).
  document.addEventListener('keydown', (e) => {
    const openDrawer = document.querySelector<HTMLElement>('.drawer[data-open="true"]');
    if (!openDrawer) return;

    if (e.key === 'Escape') {
      (window as any).closeDrawer(openDrawer.id);
      return;
    }

    if (e.key === 'Tab') {
      const focusable = openDrawer.querySelectorAll<HTMLElement>(
        'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
      );
      if (focusable.length === 0) return;
      const first = focusable[0];
      const last = focusable[focusable.length - 1];
      if (e.shiftKey) {
        if (document.activeElement === first) {
          e.preventDefault();
          last.focus();
        }
      } else {
        if (document.activeElement === last) {
          e.preventDefault();
          first.focus();
        }
      }
    }
  });

  // Global drawer API
  (window as any).openDrawer = (id: string) => {
    const drawer = document.getElementById(id);
    if (drawer) {
      (drawer as any)._triggerElement = document.activeElement;
      drawer.dataset.open = 'true';
      document.body.style.overflow = 'hidden';
      // Focus the container for screen readers (outline suppressed via CSS)
      const container = drawer.querySelector<HTMLElement>('.drawer-container');
      if (container) {
        container.setAttribute('tabindex', '-1');
        requestAnimationFrame(() => container.focus());
      }
    }
  };

  (window as any).closeDrawer = (id: string) => {
    const drawer = document.getElementById(id);
    if (drawer) {
      const trigger = (drawer as any)._triggerElement as HTMLElement | null;
      const container = drawer.querySelector('.drawer-container') as HTMLElement;
      drawer.classList.add('closing');
      setTimeout(() => {
        drawer.dataset.open = 'false';
        drawer.classList.remove('closing');
        if (container) container.style.transform = '';
        document.body.style.overflow = '';
        if (trigger && typeof trigger.focus === 'function') trigger.focus();
      }, 250);
    }
  };
</script>
